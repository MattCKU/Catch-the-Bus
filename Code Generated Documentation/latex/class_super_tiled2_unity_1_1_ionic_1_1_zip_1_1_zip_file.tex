\hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{}\section{Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File Class Reference}
\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}\index{Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File@{Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File}}


The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} type represents a zip archive file.  


Inheritance diagram for Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=1.138211cm]{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Add\+Item}} (string file\+Or\+Directory\+Name)
\begin{DoxyCompactList}\small\item\em Adds an item, either a file or a directory, to a zip file archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4f5b34dc261ef4f4af63d0a692d9cfc6}{Add\+Item}} (String file\+Or\+Directory\+Name, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds an item, either a file or a directory, to a zip file archive, explicitly specifying the directory path to be used in the archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Adds a File to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a265dc7dabc22f57400b3b8c8c2ce43c2}{Add\+File}} (string file\+Name, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds a File to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive, potentially overriding the path to be used within the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9347964fdaa19da7fd253f53b0f550c}{Remove\+Entries}} (System.\+Collections.\+Generic.\+I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ entries\+To\+Remove)
\begin{DoxyCompactList}\small\item\em This method removes a collection of entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a110e34e551b1282f9eaf1dfac5d58dac}{Remove\+Entries}} (System.\+Collections.\+Generic.\+I\+Collection$<$ String $>$ entries\+To\+Remove)
\begin{DoxyCompactList}\small\item\em This method removes a collection of entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, by name. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aec731f8e3920d0028fc746c7b71e60a7}{Add\+Files}} (System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$ file\+Names)
\begin{DoxyCompactList}\small\item\em This method adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4904d47eb715c7c6188e067c7142e1a6}{Update\+Files}} (System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$ file\+Names)
\begin{DoxyCompactList}\small\item\em Adds or updates a set of files in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a93ca8dfa47090d70efdd86f6960f42a9}{Add\+Files}} (System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$ file\+Names, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5f0daa18dd5b12972b572d2dae1af918}{Add\+Files}} (System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$ file\+Names, bool preserve\+Dir\+Hierarchy, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive, and preserving the full directory structure in the filenames. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae27ba30d3eb9d3c97aa4e89684f9f56a}{Update\+Files}} (System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$ file\+Names, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds or updates a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}{Update\+File}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Adds or Updates a File in a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5acb9856007c971996495db1ffd8f063}{Update\+File}} (string file\+Name, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds or Updates a File in a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}{Update\+Directory}} (string directory\+Name)
\begin{DoxyCompactList}\small\item\em Add or update a directory in a zip archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa1a7a2fe435a46b6ba009b1f6a24c28f}{Update\+Directory}} (string directory\+Name, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Add or update a directory in the zip archive at the specified root directory in the archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}{Update\+Item}} (string item\+Name)
\begin{DoxyCompactList}\small\item\em Add or update a file or directory in the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}{Update\+Item}} (string item\+Name, string directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Add or update a file or directory. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{Add\+Entry}} (string entry\+Name, string content)
\begin{DoxyCompactList}\small\item\em Adds a named entry into the zip archive, taking content for the entry from a string. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab9096c2f2144577876b72216b3ef5c34}{Add\+Entry}} (string entry\+Name, string content, System.\+Text.\+Encoding encoding)
\begin{DoxyCompactList}\small\item\em Adds a named entry into the zip archive, taking content for the entry from a string, and using the specified text encoding. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5ae21397e59e0699aa8701822477e537}{Add\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} stream)
\begin{DoxyCompactList}\small\item\em Create an entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} using the given {\ttfamily Stream} as input. The entry will have the given filename. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4db76147d4354e087063303abc6a4ec4}{Add\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a6b1de844c6db599faedbfc860c6744f6}{Write\+Delegate}} writer)
\begin{DoxyCompactList}\small\item\em Add a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} for which content is written directly by the application. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca70604c3928ce13d5028d31b7d491fd}{Add\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a02583f9b7b1b724562c5ead6715256f2}{Open\+Delegate}} opener, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a19b625523fef0bcff4722ebb8a04b5d0}{Close\+Delegate}} closer)
\begin{DoxyCompactList}\small\item\em Add an entry, for which the application will provide a stream containing the entry data, on a just-\/in-\/time basis. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af76606d95dccbe41f72679cae14f06da}{Update\+Entry}} (string entry\+Name, string content)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given string as content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad70399fae6bee75df23d40b96228f167}{Update\+Entry}} (string entry\+Name, string content, System.\+Text.\+Encoding encoding)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given string as content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a632235fdf4c9592741f1a736a6b484a4}{Update\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a6b1de844c6db599faedbfc860c6744f6}{Write\+Delegate}} writer)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given delegate as the source for content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a99b7c52499dded09ebea471c35ab04ce}{Update\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a02583f9b7b1b724562c5ead6715256f2}{Open\+Delegate}} opener, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a19b625523fef0bcff4722ebb8a04b5d0}{Close\+Delegate}} closer)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given delegates to open and close the stream that provides the content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb3ebc0df8d7fa7d039eba7292e71330}{Update\+Entry}} (string entry\+Name, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} stream)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given stream as input, and the given filename and given directory Path. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adfff34d116111c6f10073e4fa77e715d}{Add\+Entry}} (string entry\+Name, byte\mbox{[}$\,$\mbox{]} byte\+Content)
\begin{DoxyCompactList}\small\item\em Add an entry into the zip archive using the given filename and directory path within the archive, and the given content for the file. No file is created in the filesystem. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9a344d2fa379b4b020119d64b1f8e5f0}{Update\+Entry}} (string entry\+Name, byte\mbox{[}$\,$\mbox{]} byte\+Content)
\begin{DoxyCompactList}\small\item\em Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given byte array as content for the entry. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory}} (string directory\+Name)
\begin{DoxyCompactList}\small\item\em Adds the contents of a filesystem directory to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}{Add\+Directory}} (string directory\+Name, string directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds the contents of a filesystem directory to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive, overriding the path to be used for entries in the archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac4c259bf5a55746b6c16a27a304f6327}{Add\+Directory\+By\+Name}} (string directory\+Name\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Creates a directory in the zip archive. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae031db150a3aa82ad89e922ce2ac4840}{Contains\+Entry}} (string name)
\begin{DoxyCompactList}\small\item\em Returns true if an entry by the given name exists in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
override String \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae341d900330121d5dd845d881185537b}{To\+String}} ()
\begin{DoxyCompactList}\small\item\em Provides a string representation of the instance.\end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2acccba29683cd64e9e3bbf252f024f8}{Zip\+File}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified filename. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a26a9c19cc65934f2ef15aa1e85256293}{Zip\+File}} (string file\+Name, System.\+Text.\+Encoding encoding)
\begin{DoxyCompactList}\small\item\em Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, and the specified \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{Zip\+File}} ()
\begin{DoxyCompactList}\small\item\em Create a zip file, without specifying a target filename or stream to save to. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa962f7f22706635121fa367c5f90a5}{Zip\+File}} (System.\+Text.\+Encoding encoding)
\begin{DoxyCompactList}\small\item\em Create a zip file, specifying a text \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}, but without specifying a target filename or stream to save to. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae6622886024bc08b04bde23355fd5020}{Zip\+File}} (string file\+Name, Text\+Writer status\+Message\+Writer)
\begin{DoxyCompactList}\small\item\em Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, and the specified status message writer. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4c948fa55bfb6742ed3f2c2709178500}{Zip\+File}} (string file\+Name, Text\+Writer status\+Message\+Writer, System.\+Text.\+Encoding encoding)
\begin{DoxyCompactList}\small\item\em Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, the specified status message writer, and the specified \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2b07c611d58c3a2c0b59ec14eea02179}{Initialize}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Initialize a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance by reading in a zip file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}{Remove\+Entry}} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} entry)
\begin{DoxyCompactList}\small\item\em Removes the given {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} from the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a79cc2680a4476d0873bf16aec3a87360}{Remove\+Entry}} (String file\+Name)
\begin{DoxyCompactList}\small\item\em Removes the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} with the given filename from the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose}} ()
\begin{DoxyCompactList}\small\item\em Closes the read and write streams associated to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, if necessary. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acf65879aa66b0f58c5af340264b54374}{Extract\+All}} (string path)
\begin{DoxyCompactList}\small\item\em Extracts all of the items in the zip archive, to the specified path in the filesystem. The path can be relative or fully-\/qualified. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0f8bd27ce81b112d252c8cd2e1f06934}{Extract\+All}} (string path, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}} extract\+Existing\+File)
\begin{DoxyCompactList}\small\item\em Extracts all of the items in the zip archive, to the specified path in the filesystem, using the specified behavior when extraction would overwrite an existing file. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}} ()
\begin{DoxyCompactList}\small\item\em Saves the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive to a file, specified by the Name property of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}{Save}} (String file\+Name)
\begin{DoxyCompactList}\small\item\em Save the file to a new zipfile, with the given name. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af6e6cb1b5da4c7e97bde2dfe1cac3fd1}{Save}} (\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} output\+Stream)
\begin{DoxyCompactList}\small\item\em Save the zip archive to the specified stream. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{Save\+Self\+Extractor}} (string exe\+To\+Generate, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{Self\+Extractor\+Flavor}} flavor)
\begin{DoxyCompactList}\small\item\em Saves the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance to a self-\/extracting zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a064e912a1571a38845e5ee1666ca94db}{Save\+Self\+Extractor}} (string exe\+To\+Generate, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_self_extractor_save_options}{Self\+Extractor\+Save\+Options}} options)
\begin{DoxyCompactList}\small\item\em Saves the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance to a self-\/extracting zip archive, using the specified save options. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files}} (String selection\+Criteria)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the current working directory on disk, that conform to the specified criteria. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad870726d9ab09168d2f1525fd61826bb}{Add\+Selected\+Files}} (String selection\+Criteria, bool recurse\+Directories)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the disk that conform to the specified criteria, optionally recursing into subdirectories. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}{Add\+Selected\+Files}} (String selection\+Criteria, String directory\+On\+Disk)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from a specified directory in the filesystem, that conform to the specified criteria. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a501b507514805d3e5f1024315a771332}{Add\+Selected\+Files}} (String selection\+Criteria, String directory\+On\+Disk, bool recurse\+Directories)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the specified directory on disk, that conform to the specified criteria. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac91a94eb12f9285dfb84c1414bb8214e}{Add\+Selected\+Files}} (String selection\+Criteria, String directory\+On\+Disk, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a selection of files from the specified directory on disk, that conform to the specified criteria, and using a specified root path for entries added to the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a95106f452f2326adb48fc72d1450a15e}{Add\+Selected\+Files}} (String selection\+Criteria, String directory\+On\+Disk, String directory\+Path\+In\+Archive, bool recurse\+Directories)
\begin{DoxyCompactList}\small\item\em Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a selection of files from the specified directory on disk, that conform to the specified criteria, optionally recursing through subdirectories, and using a specified root path for entries added to the zip archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8695fef401b3f72d145ac634bf54a154}{Update\+Selected\+Files}} (String selection\+Criteria, String directory\+On\+Disk, String directory\+Path\+In\+Archive, bool recurse\+Directories)
\begin{DoxyCompactList}\small\item\em Updates the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} with a selection of files from the disk that conform to the specified criteria. \end{DoxyCompactList}\item 
I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}{Select\+Entries}} (String selection\+Criteria)
\begin{DoxyCompactList}\small\item\em Retrieve entries from the zipfile by specified criteria. \end{DoxyCompactList}\item 
I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a76ebbeb552c977eb0622a14d5401f116}{Select\+Entries}} (String selection\+Criteria, string directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Retrieve entries from the zipfile by specified criteria. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa65fbbd260db3979088aacf9a033663f}{Remove\+Selected\+Entries}} (String selection\+Criteria)
\begin{DoxyCompactList}\small\item\em Remove entries from the zipfile by specified criteria. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbe575a1613b0f5da35f0979e3492d9}{Remove\+Selected\+Entries}} (String selection\+Criteria, string directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Remove entries from the zipfile by specified criteria, and within the specified path in the archive. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1c3f402c719453b86bec0438b649c5f4}{Extract\+Selected\+Entries}} (String selection\+Criteria)
\begin{DoxyCompactList}\small\item\em Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ace7e25684ee440ee2dfda5012e64d137}{Extract\+Selected\+Entries}} (String selection\+Criteria, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}} extract\+Existing\+File)
\begin{DoxyCompactList}\small\item\em Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1ac2b7437a1466144e783df63ff15fb4}{Extract\+Selected\+Entries}} (String selection\+Criteria, String directory\+Path\+In\+Archive)
\begin{DoxyCompactList}\small\item\em Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a823e5ba928d8990df77058f50b41ebc9}{Extract\+Selected\+Entries}} (String selection\+Criteria, string directory\+In\+Archive, string extract\+Directory)
\begin{DoxyCompactList}\small\item\em Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a577a98ca3edfabaeacd418383fb1655c}{Extract\+Selected\+Entries}} (String selection\+Criteria, string directory\+Path\+In\+Archive, string extract\+Directory, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}} extract\+Existing\+File)
\begin{DoxyCompactList}\small\item\em Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
System.\+Collections.\+Generic.\+I\+Enumerator$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad3c41dee19a5bb1f2779ec232d3c3d0f}{Get\+Enumerator}} ()
\begin{DoxyCompactList}\small\item\em Generic I\+Enumerator support, for use of a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} in an enumeration. \end{DoxyCompactList}\item 
System.\+Collections.\+I\+Enumerator \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a884c0d3669a3f3e80ec6280dfbfa3882}{Get\+New\+Enum}} ()
\begin{DoxyCompactList}\small\item\em An I\+Enumerator, for use of a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} in a foreach construct. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a25223986c875661870fa62d08d68ef45}{Check\+Zip}} (string zip\+File\+Name)
\begin{DoxyCompactList}\small\item\em Checks a zip file to see if its directory is consistent. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a74ae77bf0b002c61ffe54815d405adec}{Check\+Zip}} (string zip\+File\+Name, bool fix\+If\+Necessary, Text\+Writer writer)
\begin{DoxyCompactList}\small\item\em Checks a zip file to see if its directory is consistent, and optionally fixes the directory if necessary. \end{DoxyCompactList}\item 
static void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca101c62532b74ff851ba8f18e0c9091}{Fix\+Zip\+Directory}} (string zip\+File\+Name)
\begin{DoxyCompactList}\small\item\em Rewrite the directory within a zipfile. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abb1bba30c02b71822a1053fa5f4a8204}{Check\+Zip\+Password}} (string zip\+File\+Name, string password)
\begin{DoxyCompactList}\small\item\em Verify the password on a zip file. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Read}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Reads a zip file archive and returns the instance. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af8aab0e7643c202a2171731288230d59}{Read}} (string file\+Name, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_options}{Read\+Options}} options)
\begin{DoxyCompactList}\small\item\em Reads a zip file archive from the named filesystem file using the specified options. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a51271b0f357c968e6f34be8f1daec490}{Read}} (\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} zip\+Stream)
\begin{DoxyCompactList}\small\item\em Reads a zip archive from a stream. \end{DoxyCompactList}\item 
static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a158599d431cb5649f7729fd6f9a1e0af}{Read}} (\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} zip\+Stream, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_options}{Read\+Options}} options)
\begin{DoxyCompactList}\small\item\em Reads a zip file archive from the given stream using the specified options. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae768213f1dc3cd7a1d62cf42af359d2b}{Is\+Zip\+File}} (string file\+Name)
\begin{DoxyCompactList}\small\item\em Checks the given file to see if it appears to be a valid zip file. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abc936816e59ebc2a66ace620b6bc2632}{Is\+Zip\+File}} (string file\+Name, bool test\+Extract)
\begin{DoxyCompactList}\small\item\em Checks a file to see if it is a valid zip file. \end{DoxyCompactList}\item 
static bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5a708fa7eafd96bfc010b5419b878544}{Is\+Zip\+File}} (\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}} stream, bool test\+Extract)
\begin{DoxyCompactList}\small\item\em Checks a stream to see if it contains a valid zip archive. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static readonly int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9b06e16fba338b0ab3d2011d0b5b3aad}{Buffer\+Size\+Default}} = 32768
\begin{DoxyCompactList}\small\item\em Default size of the buffer used for IO. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aea428408377b5d7e0487bd86bf8c1d4b}{Dispose}} (bool dispose\+Managed\+Resources)
\begin{DoxyCompactList}\small\item\em Disposes any managed resources, if the flag is set, then marks the instance disposed. This method is typically not called explicitly from application code. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Properties}
\begin{DoxyCompactItemize}
\item 
string \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae4fcb9391e4a839218b63c4c129883b3}{Info}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Provides a human-\/readable string with information about the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0ce8fe1d66e96dc3deb4f2425573e567}{Full\+Scan}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether to perform a full scan of the zip file when reading it. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4572fef33a794fcbb717f6959b97d6f5}{Sort\+Entries\+Before\+Saving}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Whether to sort the Zip\+Entries before saving the file. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad77f3a44b8c4de55ea960a9def4181ef}{Add\+Directory\+Will\+Traverse\+Reparse\+Points}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether N\+T\+FS Reparse Points, like junctions, should be traversed during calls to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}}}. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}{Buffer\+Size}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Size of the IO buffer used while saving. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7224a4ba799edb3d0e3c47ada11eeb8c}{Codec\+Buffer\+Size}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Size of the work buffer to use for the Z\+L\+IB codec during compression. \end{DoxyCompactList}\item 
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a45e7714cf2a4dec332c2e927ad9a3d63}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a45e7714cf2a4dec332c2e927ad9a3d63}} 
bool {\bfseries Flatten\+Folders\+On\+Extract}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_abde5c10a1e2ee453e1e8e22e79a39a3b}{Ionic.\+Zlib.\+Compression\+Strategy}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a891511a2bde8493e29fb7c473f4e6eee}{Strategy}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The compression strategy to use for all entries. \end{DoxyCompactList}\item 
string \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}{Name}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The name of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, on disk. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_a20f6771804996c363f454ad9765cd7db}{Ionic.\+Zlib.\+Compression\+Level}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Sets the compression level to be used for entries subsequently added to the zip archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a48fd7a4529dd87fb2fda54f62ae3d8a3}{Ionic.\+Zip.\+Compression\+Method}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3fa017cd62445ff4041b5958dfb4ab2e}{Compression\+Method}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The compression method for the zipfile. \end{DoxyCompactList}\item 
string \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em A comment attached to the zip archive. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1695d2181d639029b132e67c85734e8c}{Emit\+Times\+In\+Windows\+Format\+When\+Saving}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Specifies whether the Creation, Access, and Modified times for entries added to the zip file will be emitted in \&\#147;Windows format\&\#148; when the zip archive is saved. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af369a36c1bf83fc28466fe15c095ea87}{Emit\+Times\+In\+Unix\+Format\+When\+Saving}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Specifies whether the Creation, Access, and Modified times for entries added to the zip file will be emitted in \char`\"{}\+Unix(tm)
format\char`\"{} when the zip archive is saved. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeb25467e1a84cabe712c5a30603d3bf6}{Case\+Sensitive\+Retrieval}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether to perform case-\/sensitive matching on the filename when retrieving entries in the zipfile via the string-\/based indexer. \end{DoxyCompactList}\item 
bool \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa55d8b8c5ff20f83892d7d4c694c4b6a}{Use\+Unicode\+As\+Necessary}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether to encode entry filenames and entry comments using Unicode (U\+T\+F-\/8). \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64\+Option}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Use\+Zip64\+When\+Saving}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Specify whether to use Z\+I\+P64 extensions when saving a zip archive. \end{DoxyCompactList}\item 
Nullable$<$ bool $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9901125cb78c8e646a6e516669334632}{Requires\+Zip64}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether the archive requires Z\+I\+P64 extensions. \end{DoxyCompactList}\item 
Nullable$<$ bool $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}{Output\+Used\+Zip64}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} operation used Z\+I\+P64 extensions. \end{DoxyCompactList}\item 
Nullable$<$ bool $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a613f1159ee59c2ee7bf682567579ad09}{Input\+Uses\+Zip64}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Indicates whether the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Read()}}} operation read a zip file that uses Z\+I\+P64 extensions. \end{DoxyCompactList}\item 
System.\+Text.\+Encoding \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The text encoding to use when writing new entries to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, for those entries that cannot be encoded with the default (I\+B\+M437) encoding; or, the text encoding that was used when reading the entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
System.\+Text.\+Encoding \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em A Text \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} to use when encoding the filenames and comments for all the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items, during a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} operation. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a25d431031427c142eba970006eee630c}{Zip\+Option}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}{Alternate\+Encoding\+Usage}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em A flag that tells if and when this instance should apply Alternate\+Encoding to encode the filenames and comments associated to of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} objects contained within this instance. \end{DoxyCompactList}\item 
static System.\+Text.\+Encoding \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a55217486008cf80cba92210c592471f1}{Default\+Encoding}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em The default text encoding used in zip archives. It is numeric 437, also known as I\+B\+M437. \end{DoxyCompactList}\item 
Text\+Writer \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}{Status\+Message\+Text\+Writer}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets or sets the {\ttfamily Text\+Writer} to which status messages are delivered for the instance. \end{DoxyCompactList}\item 
String \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5b51af53eca5a8c0aa52d950f04c4add}{Temp\+File\+Folder}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Gets or sets the name for the folder to store the temporary file this library writes when saving a zip archive. \end{DoxyCompactList}\item 
String \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}\hspace{0.3cm}{\ttfamily  \mbox{[}set\mbox{]}}
\begin{DoxyCompactList}\small\item\em Sets the password to be used on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The action the library should take when extracting a file that already exists. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593}{Zip\+Error\+Action}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The action the library should take when an error is encountered while opening or reading files as they are saved into a zip archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa3f4e8aa12ef827ac72177a49b4e28e6}{Encryption\+Algorithm}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The Encryption to use for entries added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \end{DoxyCompactList}\item 
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_ab6b15a72531220e6f98c46b594c9a849}{Set\+Compression\+Callback}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em A callback that allows the application to specify the compression level to use for entries subsequently added to the zip archive. \end{DoxyCompactList}\item 
Int32 \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}{Max\+Output\+Segment\+Size}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The maximum size of an output segment, when saving a split \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file. \end{DoxyCompactList}\item 
Int32 \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7968b0265bacd1a670497fd87c824cef}{Number\+Of\+Segments\+For\+Most\+Recent\+Save}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the number of segments used in the most recent \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} operation. \end{DoxyCompactList}\item 
long \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab5cbcfc51b1d21f281ae8d2db8c4ded9}{Parallel\+Deflate\+Threshold}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The size threshold for an entry, above which a parallel deflate is used. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad0e3f7ed7377d0d8d71154d893375fb5}{Parallel\+Deflate\+Max\+Buffer\+Pairs}}\hspace{0.3cm}{\ttfamily  \mbox{[}get, set\mbox{]}}
\begin{DoxyCompactList}\small\item\em The maximum number of buffer pairs to use when performing parallel compression. \end{DoxyCompactList}\item 
static System.\+Version \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9c12c0e7927c8d1fff6abd5f80e1125}{Library\+Version}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the version number on the Dot\+Net\+Zip assembly. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a6c57057729f935413dd8fc2945dfb378}{this\mbox{[}int ix\mbox{]}}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em This is an integer indexer into the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. \end{DoxyCompactList}\item 
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9d0f9d576a79c40859970894bcb171f4}{this\mbox{[}\+String file\+Name\mbox{]}}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em This is a name-\/based indexer into the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. \end{DoxyCompactList}\item 
System.\+Collections.\+Generic.\+I\+Collection$<$ String $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a978fb90dbd4c922c55921d1ae8f631d5}{Entry\+File\+Names}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em The list of filenames for the entries contained within the zip archive. \end{DoxyCompactList}\item 
System.\+Collections.\+Generic.\+I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a09b9d3aecc21754ab8a9d950b20de72b}{Entries}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the readonly collection of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. \end{DoxyCompactList}\item 
System.\+Collections.\+Generic.\+I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad4da87108d27a1ee534a16333fa39fd7}{Entries\+Sorted}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns a readonly collection of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive, sorted by File\+Name. \end{DoxyCompactList}\item 
int \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab47cd362deaea15bb16ecc8654391d6b}{Count}}\hspace{0.3cm}{\ttfamily  \mbox{[}get\mbox{]}}
\begin{DoxyCompactList}\small\item\em Returns the number of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. \end{DoxyCompactList}\end{DoxyCompactItemize}
\subsection*{Events}
\begin{DoxyCompactItemize}
\item 
Event\+Handler$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_save_progress_event_args}{Save\+Progress\+Event\+Args}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{Save\+Progress}}
\begin{DoxyCompactList}\small\item\em An event handler invoked when a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} starts, before and after each entry has been written to the archive, when a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} completes, and during other Save events. \end{DoxyCompactList}\item 
Event\+Handler$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_progress_event_args}{Read\+Progress\+Event\+Args}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}{Read\+Progress}}
\begin{DoxyCompactList}\small\item\em An event handler invoked before, during, and after the reading of a zip archive. \end{DoxyCompactList}\item 
Event\+Handler$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_extract_progress_event_args}{Extract\+Progress\+Event\+Args}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{Extract\+Progress}}
\begin{DoxyCompactList}\small\item\em An event handler invoked before, during, and after extraction of entries in the zip archive. \end{DoxyCompactList}\item 
Event\+Handler$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_add_progress_event_args}{Add\+Progress\+Event\+Args}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}{Add\+Progress}}
\begin{DoxyCompactList}\small\item\em An event handler invoked before, during, and after Adding entries to a zip archive. \end{DoxyCompactList}\item 
Event\+Handler$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_error_event_args}{Zip\+Error\+Event\+Args}} $>$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9c72461567386905e4e52ccb312e4812}{Zip\+Error}}
\begin{DoxyCompactList}\small\item\em An event that is raised when an error occurs during open or read of files while saving a zip archive. \end{DoxyCompactList}\end{DoxyCompactItemize}


\subsection{Detailed Description}
The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} type represents a zip archive file. 

This is the main type in the Dot\+Net\+Zip class library. This class reads and writes zip files, as defined in the specification for zip files described by P\+K\+Ware

. The compression for this implementation is provided by a managed-\/code version of \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib}{Zlib}}, included with Dot\+Net\+Zip in the classes in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib}{Ionic.\+Zlib}} namespace. 

This class provides a general purpose zip file capability. Use it to read, create, or update zip files. When you want to create zip files using a {\ttfamily Stream} type to write the zip file, you may want to consider the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}} class. 

Both the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} class and the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class can be used to create zip files. Both of them support many of the common zip features, including Unicode, different compression methods and levels, and Z\+I\+P64. They provide very similar performance when creating zip files. 

The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class is generally easier to use than {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} and should be considered a higher-\/level interface. For example, when creating a zip file via calls to the {\ttfamily Put\+Next\+Entry()} and {\ttfamily Write()} methods on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} class, the caller is responsible for opening the file, reading the bytes from the file, writing those bytes into the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}}, setting the attributes on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}, and setting the created, last modified, and last accessed timestamps on the zip entry. All of these things are done automatically by a call to \mbox{\hyperlink{}{Zip\+File.\+Add\+File()}}. For this reason, the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} is generally recommended for use only when your application emits arbitrary data, not necessarily data from a filesystem file, directly into a zip file, and does so using a {\ttfamily Stream} metaphor. 

Aside from the differences in programming model, there are other differences in capability between the two classes. 


\begin{DoxyItemize}
\item {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} can be used to read and extract zip files, in addition to creating zip files. {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} cannot read zip files. If you want to use a stream to read zip files, check out the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_input_stream}{Zip\+Input\+Stream}} class. 


\item {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} does not support the creation of segmented or spanned zip files. 


\item {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_output_stream}{Zip\+Output\+Stream}}} cannot produce a self-\/extracting archive.  
\end{DoxyItemize}

Be aware that the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class implements the System.\+I\+Disposable interface. In order for {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} to produce a valid zip file, you use use it within a using clause ({\ttfamily Using} in VB), or call the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose()}}} method explicitly. See the examples for how to employ a using clause. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2acccba29683cd64e9e3bbf252f024f8}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2acccba29683cd64e9e3bbf252f024f8}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})}



Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified filename. 

Applications can use this constructor to create a new \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} for writing, or to slurp in an existing zip archive for read and update purposes. 

To create a new zip archive, an application can call this constructor, passing the name of a file that does not exist. The name may be a fully qualified path. Then the application can add directories or files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} via {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}}}, {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File()}}}, {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Add\+Item()}}} and then write the zip archive to the disk by calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. The zip file is not actually opened and written to the disk until the application calls {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}. At that point the new zip file with the given name is created. 

If you won\textquotesingle{}t know the name of the {\ttfamily Zipfile} until the time you call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}, or if you plan to save to a stream (which has no name), then you should use the no-\/argument constructor. 

The application can also call this constructor to read an existing zip archive. passing the name of a valid zip file that does exist. But, it\textquotesingle{}s better form to use the static Zip\+File.\+Read(\+String) method, passing the name of the zip file, because using {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}} in your code communicates very clearly what you are doing. In either case, the file is then read into the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. The app can then enumerate the entries or can modify the zip file, for example adding entries, removing entries, changing comments, and so on. 

One advantage to this parameterized constructor\+: it allows applications to use the same code to add items to a zip archive, regardless of whether the zip file exists. 

Instances of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class are not multi-\/thread safe. You may not party on a single instance with multiple threads. You may have multiple threads that each use a distinct {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, or you can synchronize multi-\/thread access to a single instance. 

By the way, since Dot\+Net\+Zip is so easy to use, don\textquotesingle{}t you think you should donate \$5 or \$10

? 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_exception}{Ionic.\+Zip.\+Zip\+Exception}}} & Thrown if name refers to an existing file that is not a valid zip file. \\
\hline
\end{DoxyExceptions}


This example shows how to create a zipfile, and add a few files into it. 
\begin{DoxyCode}
String ZipFileToCreate = \textcolor{stringliteral}{"archive1.zip"};
String DirectoryToZip  = \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)reports"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  \textcolor{comment}{// Store all files found in the top level directory, into the zip archive.}
  String[] filenames = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip);
  zip.AddFiles(filenames, \textcolor{stringliteral}{"files"});
  zip.Save(ZipFileToCreate);
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim ZipFileToCreate As String = \textcolor{stringliteral}{"archive1.zip"}
Dim DirectoryToZip As String = \textcolor{stringliteral}{"c:\(\backslash\)reports"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    Dim filenames As String() = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip)
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aec731f8e3920d0028fc746c7b71e60a7}{AddFiles}}(filenames, "files")
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(ZipFileToCreate)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & The filename to use for the new zip archive.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a26a9c19cc65934f2ef15aa1e85256293}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a26a9c19cc65934f2ef15aa1e85256293}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{System.\+Text.\+Encoding}]{encoding }\end{DoxyParamCaption})}



Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, and the specified \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}. 

See the documentation on the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a088ad16b06174c69965e232063ba6d16}{Zip\+File constructor that accepts a single string argument}} for basic information on all the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} constructors. 

The \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} is used as the default alternate encoding for entries with filenames or comments that cannot be encoded with the I\+B\+M437 code page. This is equivalent to setting the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance after construction. 

Instances of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class are not multi-\/thread safe. You may not party on a single instance with multiple threads. You may have multiple threads that each use a distinct {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, or you can synchronize multi-\/thread access to a single instance. 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_exception}{Ionic.\+Zip.\+Zip\+Exception}}} & Thrown if name refers to an existing file that is not a valid zip file. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The filename to use for the new zip archive.\\
\hline
{\em encoding} & The \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} is used as the default alternate encoding for entries with filenames or comments that cannot be encoded with the I\+B\+M437 code page. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Create a zip file, without specifying a target filename or stream to save to. 

See the documentation on the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a088ad16b06174c69965e232063ba6d16}{Zip\+File constructor that accepts a single string argument}} for basic information on all the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} constructors. 

After instantiating with this constructor and adding entries to the archive, the application should call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}{Zip\+File.\+Save(\+String)}} or \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af6e6cb1b5da4c7e97bde2dfe1cac3fd1}{Zip\+File.\+Save(\+System.\+I\+O.\+Stream)}} to save to a file or a stream, respectively. The application can also set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}{Name}} property and then call the no-\/argument \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} method. (This is the preferred approach for applications that use the library through C\+OM interop.) If you call the no-\/argument \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} method without having set the {\ttfamily Name} of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, either through the parameterized constructor or through the explicit property , the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} will throw, because there is no place to save the file. 

Instances of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class are not multi-\/thread safe. You may have multiple threads that each use a distinct {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, or you can synchronize multi-\/thread access to a single instance. 

This example creates a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive called Backup.\+zip, containing all the files in the directory Directory\+To\+Zip. Files within subdirectories are not zipped up. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  \textcolor{comment}{// Store all files found in the top level directory, into the zip archive.}
  \textcolor{comment}{// note: this code does not recurse subdirectories!}
  String[] filenames = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip);
  zip.AddFiles(filenames, \textcolor{stringliteral}{"files"});
  zip.Save(\textcolor{stringliteral}{"Backup.zip"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    \textcolor{stringliteral}{' Store all files found in the top level directory, into the zip archive.}
\textcolor{stringliteral}{    '} note: \textcolor{keyword}{this} code does not recurse subdirectories!
    Dim filenames As String() = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip)
    zip.AddFiles(filenames, \textcolor{stringliteral}{"files"})
    zip.Save(\textcolor{stringliteral}{"Backup.zip"})
End Using
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa962f7f22706635121fa367c5f90a5}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa962f7f22706635121fa367c5f90a5}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}\item[{System.\+Text.\+Encoding}]{encoding }\end{DoxyParamCaption})}



Create a zip file, specifying a text \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}, but without specifying a target filename or stream to save to. 

See the documentation on the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a088ad16b06174c69965e232063ba6d16}{Zip\+File constructor that accepts a single string argument}} for basic information on all the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} constructors. 


\begin{DoxyParams}{Parameters}
{\em encoding} & The \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} is used as the default alternate encoding for entries with filenames or comments that cannot be encoded with the I\+B\+M437 code page. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae6622886024bc08b04bde23355fd5020}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae6622886024bc08b04bde23355fd5020}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{Text\+Writer}]{status\+Message\+Writer }\end{DoxyParamCaption})}



Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, and the specified status message writer. 

See the documentation on the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a088ad16b06174c69965e232063ba6d16}{Zip\+File constructor that accepts a single string argument}} for basic information on all the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} constructors. 

This version of the constructor allows the caller to pass in a Text\+Writer, to which verbose messages will be written during extraction or creation of the zip archive. A console application may wish to pass System.\+Console.\+Out to get messages on the Console. A graphical or headless application may wish to capture the messages in a different {\ttfamily Text\+Writer}, for example, a {\ttfamily String\+Writer}, and then display the messages in a Text\+Box, or generate an audit log of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} operations. 

To encrypt the data for the files added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, set the Password property after creating the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

Instances of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class are not multi-\/thread safe. You may not party on a single instance with multiple threads. You may have multiple threads that each use a distinct {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, or you can synchronize multi-\/thread access to a single instance. 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_exception}{Ionic.\+Zip.\+Zip\+Exception}}} & Thrown if name refers to an existing file that is not a valid zip file. \\
\hline
\end{DoxyExceptions}



\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}(\textcolor{stringliteral}{"Backup.zip"}, Console.Out))
\{
  \textcolor{comment}{// Store all files found in the top level directory, into the zip archive.}
  \textcolor{comment}{// note: this code does not recurse subdirectories!}
  \textcolor{comment}{// Status messages will be written to Console.Out}
  String[] filenames = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip);
  zip.AddFiles(filenames);
  zip.Save();
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}(\textcolor{stringliteral}{"Backup.zip"}, Console.Out)
    \textcolor{stringliteral}{' Store all files found in the top level directory, into the zip archive.}
\textcolor{stringliteral}{    '} note: \textcolor{keyword}{this} code does not recurse subdirectories!
    \textcolor{stringliteral}{' Status messages will be written to Console.Out}
\textcolor{stringliteral}{    Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)}
\textcolor{stringliteral}{    zip.AddFiles(filenames)}
\textcolor{stringliteral}{    zip.Save()}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & The filename to use for the new zip archive.\\
\hline
{\em status\+Message\+Writer} & A Text\+Writer to use for writing verbose status messages.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4c948fa55bfb6742ed3f2c2709178500}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4c948fa55bfb6742ed3f2c2709178500}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+File@{Zip\+File}}
\index{Zip\+File@{Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+File()}{ZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{Text\+Writer}]{status\+Message\+Writer,  }\item[{System.\+Text.\+Encoding}]{encoding }\end{DoxyParamCaption})}



Creates a new {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, using the specified name for the filename, the specified status message writer, and the specified \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}. 

This constructor works like the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a088ad16b06174c69965e232063ba6d16}{Zip\+File constructor that accepts a single string argument.}} See that reference for detail on what this constructor does. 

This version of the constructor allows the caller to pass in a {\ttfamily Text\+Writer}, and an \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}. The {\ttfamily Text\+Writer} will collect verbose messages that are generated by the library during extraction or creation of the zip archive. A console application may wish to pass {\ttfamily System.\+Console.\+Out} to get messages on the Console. A graphical or headless application may wish to capture the messages in a different {\ttfamily Text\+Writer}, for example, a {\ttfamily String\+Writer}, and then display the messages in a {\ttfamily Text\+Box}, or generate an audit log of {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} operations. 

The {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}} is used as the default alternate encoding for entries with filenames or comments that cannot be encoded with the I\+B\+M437 code page. This is a equivalent to setting the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance after construction. 

To encrypt the data for the files added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, set the {\ttfamily Password} property after creating the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

Instances of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class are not multi-\/thread safe. You may not party on a single instance with multiple threads. You may have multiple threads that each use a distinct {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, or you can synchronize multi-\/thread access to a single instance. 


\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_exception}{Ionic.\+Zip.\+Zip\+Exception}}} & Thrown if {\ttfamily file\+Name} refers to an existing file that is not a valid zip file. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The filename to use for the new zip archive.\\
\hline
{\em status\+Message\+Writer} & A Text\+Writer to use for writing verbose status messages.\\
\hline
{\em encoding} & The \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} is used as the default alternate encoding for entries with filenames or comments that cannot be encoded with the I\+B\+M437 code page. \\
\hline
\end{DoxyParams}


\subsection{Member Function Documentation}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Directory@{Add\+Directory}}
\index{Add\+Directory@{Add\+Directory}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Directory()}{AddDirectory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Directory (\begin{DoxyParamCaption}\item[{string}]{directory\+Name }\end{DoxyParamCaption})}



Adds the contents of a filesystem directory to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. 

The name of the directory may be a relative path or a fully-\/qualified path. Any files within the named directory are added to the archive. Any subdirectories within the named directory are also added to the archive, recursively. 

Top-\/level entries in the named directory will appear as top-\/level entries in the zip archive. Entries in subdirectories in the named directory will result in entries in subdirectories in the zip archive. 

If you want the entries to appear in a containing directory in the zip archive itself, then you should call the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}} overload that allows you to explicitly specify a directory path for use in the archive. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Ionic.\+Zip.\+Zip\+File.\+Add\+File(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string, string)}}


\end{DoxySeeAlso}


$<$overloads$>$This method has 2 overloads.$<$/overloads$>$


\begin{DoxyParams}{Parameters}
{\em directory\+Name} & The name of the directory to add.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Directory@{Add\+Directory}}
\index{Add\+Directory@{Add\+Directory}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Directory()}{AddDirectory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Directory (\begin{DoxyParamCaption}\item[{string}]{directory\+Name,  }\item[{string}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds the contents of a filesystem directory to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive, overriding the path to be used for entries in the archive. 

The name of the directory may be a relative path or a fully-\/qualified path. The add operation is recursive, so that any files or subdirectories within the name directory are also added to the archive. 

Top-\/level entries in the named directory will appear as top-\/level entries in the zip archive. Entries in subdirectories in the named directory will result in entries in subdirectories in the zip archive. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 

In this code, calling the Zip\+Up() method with a value of \char`\"{}c\+:\textbackslash{}reports\char`\"{} for the directory parameter will result in a zip file structure in which all entries are contained in a toplevel \char`\"{}reports\char`\"{} directory. 


\begin{DoxyCode}
\textcolor{keyword}{public} \textcolor{keywordtype}{void} ZipUp(\textcolor{keywordtype}{string} targetZip, \textcolor{keywordtype}{string} directory)
\{
  \textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    zip.AddDirectory(directory, \mbox{\hyperlink{namespace_system}{System}}.IO.Path.GetFileName(directory));
    zip.Save(targetZip);
  \}
\}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string, string), Ionic.\+Zip.\+Zip\+File.\+Add\+File(string, string), Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string, string)


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em directory\+Name} & The name of the directory to add.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the Directory\+Name. This path may, or may not, correspond to a real directory in the current filesystem. If the zip is later extracted, this is the path used for the extracted file or directory. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) or the empty string (\char`\"{}\char`\"{}) will insert the items at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac4c259bf5a55746b6c16a27a304f6327}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac4c259bf5a55746b6c16a27a304f6327}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Directory\+By\+Name@{Add\+Directory\+By\+Name}}
\index{Add\+Directory\+By\+Name@{Add\+Directory\+By\+Name}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Directory\+By\+Name()}{AddDirectoryByName()}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Directory\+By\+Name (\begin{DoxyParamCaption}\item[{string}]{directory\+Name\+In\+Archive }\end{DoxyParamCaption})}



Creates a directory in the zip archive. 

Use this when you want to create a directory in the archive but there is no corresponding filesystem representation for that directory. 

You will probably not need to do this in your code. One of the only times you will want to do this is if you want an empty directory in the zip archive. The reason\+: if you add a file to a zip archive that is stored within a multi-\/level directory, all of the directory tree is implicitly created in the zip archive. 


\begin{DoxyParams}{Parameters}
{\em directory\+Name\+In\+Archive} & The name of the directory to create in the archive. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{string}]{content }\end{DoxyParamCaption})}



Adds a named entry into the zip archive, taking content for the entry from a string. 

Calling this method creates an entry using the given file\+Name and directory path within the archive. There is no need for a file by the given name to exist in the filesystem; the name is used within the zip archive only. The content for the entry is encoded using the default text encoding for the machine, or on Silverlight, using U\+T\+F-\/8. 


\begin{DoxyParams}{Parameters}
{\em content} & The content of the file, should it be extracted from the zip. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use for the entry within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}


This example shows how to add an entry to the zipfile, using a string as content for that entry.


\begin{DoxyCode}
\textcolor{keywordtype}{string} Content = \textcolor{stringliteral}{"This string will be the content of the Readme.txt file in the zip archive."};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  zip1.AddFile(\textcolor{stringliteral}{"MyDocuments\(\backslash\)\(\backslash\)Resume.doc"}, \textcolor{stringliteral}{"files"});
  zip1.AddEntry(\textcolor{stringliteral}{"Readme.txt"}, Content);
  zip1.Comment = \textcolor{stringliteral}{"This zip file was created at "} + \mbox{\hyperlink{namespace_system}{System}}.DateTime.Now.ToString(\textcolor{stringliteral}{"G"});
  zip1.Save(\textcolor{stringliteral}{"Content.zip"});
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Public Sub Run()
  Dim Content As String = "This \textcolor{keywordtype}{string} will be the content of the Readme.txt file in the zip archive."
  Using zip1 As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip1.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{AddEntry}}("Readme.txt", Content)
    zip1.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{AddFile}}("MyDocuments\(\backslash\)Resume.doc", "files")
    zip1.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}} = ("This zip file was created at " &amp; DateTime.Now.
      \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae341d900330121d5dd845d881185537b}{ToString}}("G"))
    zip1.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}("Content.zip")
  End Using
End Sub
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab9096c2f2144577876b72216b3ef5c34}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab9096c2f2144577876b72216b3ef5c34}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{string}]{content,  }\item[{System.\+Text.\+Encoding}]{encoding }\end{DoxyParamCaption})}



Adds a named entry into the zip archive, taking content for the entry from a string, and using the specified text encoding. 

Calling this method creates an entry using the given file\+Name and directory path within the archive. There is no need for a file by the given name to exist in the filesystem; the name is used within the zip archive only. 

The content for the entry, a string value, is encoded using the given text encoding. A B\+OM (byte-\/order-\/mark) is emitted into the file, if the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} parameter is set for that. 

Most \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} classes support a constructor that accepts a boolean, indicating whether to emit a B\+OM or not. For example see System.\+Text.\+U\+T\+F8\+Encoding(bool). 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em content} & The content of the file, should it be extracted from the zip. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em encoding} & The text encoding to use when encoding the string. Be aware\+: This is distinct from the text encoding used to encode the file\+Name, as specified in \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5ae21397e59e0699aa8701822477e537}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5ae21397e59e0699aa8701822477e537}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{stream }\end{DoxyParamCaption})}



Create an entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} using the given {\ttfamily Stream} as input. The entry will have the given filename. 

The application should provide an open, readable stream; in this case it will be read during the call to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} or one of its overloads. 

The passed stream will be read from its current position. If necessary, callers should set the position in the stream before calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{Add\+Entry()}}. This might be appropriate when using this method with a Memory\+Stream, for example. 

In cases where a large number of streams will be added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, the application may wish to avoid maintaining all of the streams open simultaneously. To handle this situation, the application should use the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca70604c3928ce13d5028d31b7d491fd}{Add\+Entry(string, Open\+Delegate, Close\+Delegate)}} overload. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

This example adds a single entry to a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} via a {\ttfamily Stream}. 


\begin{DoxyCode}
String zipToCreate = \textcolor{stringliteral}{"Content.zip"};
String fileNameInArchive = \textcolor{stringliteral}{"Content-From-Stream.bin"};
\textcolor{keyword}{using} (\mbox{\hyperlink{namespace_system}{System}}.IO.Stream streamToRead = MyStreamOpener())
\{
  \textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    ZipEntry entry= zip.AddEntry(fileNameInArchive, streamToRead);
    zip.AddFile(\textcolor{stringliteral}{"Readme.txt"});
    zip.Save(zipToCreate);  \textcolor{comment}{// the stream is read implicitly here}
  \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim zipToCreate As String = \textcolor{stringliteral}{"Content.zip"}
Dim fileNameInArchive As String = \textcolor{stringliteral}{"Content-From-Stream.bin"}
Using streamToRead as \mbox{\hyperlink{namespace_system}{System}}.IO.Stream = MyStreamOpener()
  Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    Dim entry as ZipEntry = zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{AddEntry}}(fileNameInArchive, streamToRead)
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{AddFile}}("Readme.txt")
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(zipToCreate)  '' the stream is read implicitly, here
  End Using
End Using
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb3ebc0df8d7fa7d039eba7292e71330}{Ionic.\+Zip.\+Zip\+File.\+Update\+Entry(string, System.\+I\+O.\+Stream)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, which is shown in the zip file for the added entry. \\
\hline
{\em stream} & The input stream from which to grab content for the file \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4db76147d4354e087063303abc6a4ec4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4db76147d4354e087063303abc6a4ec4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a6b1de844c6db599faedbfc860c6744f6}{Write\+Delegate}}}]{writer }\end{DoxyParamCaption})}



Add a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} for which content is written directly by the application. 

When the application needs to write the zip entry data, use this method to add the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}. For example, in the case that the application wishes to write the X\+ML representation of a Data\+Set into a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}, the application can use this method to do so. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

About progress events\+: When using the Write\+Delegate, Dot\+Net\+Zip does not issue any Save\+Progress events with {\ttfamily Event\+Type} = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa854ff1908364575616ad901a1050978b}{Saving\+\_\+\+Entry\+Bytes\+Read}}. (This is because it is the application\textquotesingle{}s code that runs in Write\+Delegate -\/ there\textquotesingle{}s no way for Dot\+Net\+Zip to know when to issue a Entry\+Bytes\+Read event.) Applications that want to update a progress bar or similar status indicator should do so from within the Write\+Delegate itself. Dot\+Net\+Zip will issue the other Save\+Progress events, including \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa981045d76077160a65da34e56daa04ba}{Saving\+\_\+\+Started}}, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa6a5772cb33fcfbfbe2f970efdac29ac4}{Saving\+\_\+\+Before\+Write\+Entry}}, and \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa25e89555bbf919c6e0d8d535bbdfcc67}{Saving\+\_\+\+After\+Write\+Entry}}. 

Note\+: When you use P\+K\+Zip encryption, it\textquotesingle{}s normally necessary to compute the C\+RC of the content to be encrypted, before compressing or encrypting it. Therefore, when using P\+K\+Zip encryption with a Write\+Delegate, the Write\+Delegate C\+AN BE called twice\+: once to compute the C\+RC, and the second time to potentially compress and encrypt. Surprising, but true. This is because P\+K\+W\+A\+RE specified that the encryption initialization data depends on the C\+RC. If this happens, for each call of the delegate, your application must stream the same entry data in its entirety. If your application writes different data during the second call, it will result in a corrupt zip file. 

The double-\/read behavior happens with all types of entries, not only those that use Write\+Delegate. It happens if you add an entry from a filesystem file, or using a string, or a stream, or an opener/closer pair. But in those cases, Dot\+Net\+Zip takes care of reading twice; in the case of the Write\+Delegate, the application code gets invoked twice. Be aware. 

As you can imagine, this can cause performance problems for large streams, and it can lead to correctness problems when you use a {\ttfamily Write\+Delegate}. This is a pretty big pitfall. There are two ways to avoid it. First, and most preferred\+: don\textquotesingle{}t use P\+K\+Z\+IP encryption. If you use the Win\+Zip A\+ES encryption, this problem doesn\textquotesingle{}t occur, because the encryption protocol doesn\textquotesingle{}t require the C\+RC up front. Second\+: if you do choose to use P\+K\+Z\+IP encryption, write out to a non-\/seekable stream (like standard output, or the Response.\+Output\+Stream in an A\+S\+P.\+N\+ET application). In this case, Dot\+Net\+Zip will use an alternative encryption protocol that does not rely on the C\+RC of the content. This also implies setting bit 3 in the zip entry, which still presents problems for some zip tools. 

In the future I may modify Dot\+Net\+Zip to {\itshape always} use bit 3 when P\+K\+Z\+IP encryption is in use. This seems like a win overall, but there will be some work involved. If you feel strongly about it, visit the Dot\+Net\+Zip forums and vote up the Workitem tracking this issue

. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & the name of the entry to add\\
\hline
{\em writer} & the delegate which will write the entry content\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added
\end{DoxyReturn}


This example shows an application filling a Data\+Set, then saving the contents of that Data\+Set as X\+ML, into a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} in a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, using an anonymous delegate in C\#. The Data\+Set X\+ML is never saved to a disk file.


\begin{DoxyCode}
var c1= \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.Data.SqlClient.SqlConnection(connstring1);
var da = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.Data.SqlClient.SqlDataAdapter()
    \{
        SelectCommand=  \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.Data.SqlClient.SqlCommand(strSelect, c1)
    \};

DataSet ds1 = \textcolor{keyword}{new} DataSet();
da.Fill(ds1, \textcolor{stringliteral}{"Invoices"});

\textcolor{keyword}{using}(Ionic.Zip.ZipFile zip = \textcolor{keyword}{new} Ionic.Zip.ZipFile())
\{
    zip.AddEntry(zipEntryName, (name,stream) => ds1.WriteXml(stream) );
    zip.Save(zipFileName);
\}
\end{DoxyCode}
 

This example uses an anonymous method in C\# as the Write\+Delegate to provide the data for the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}. The example is a bit contrived -\/ the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File()}}} method is a simpler way to insert the contents of a file into an entry in a zip file. On the other hand, if there is some sort of processing or transformation of the file contents required before writing, the application could use the {\ttfamily Write\+Delegate} to do it, in this way.


\begin{DoxyCode}
\textcolor{keyword}{using} (var input = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ))
\{
    \textcolor{keyword}{using}(Ionic.Zip.ZipFile zip = \textcolor{keyword}{new} Ionic.Zip.ZipFile())
    \{
        zip.AddEntry(zipEntryName, (name,output) =>
            \{
                byte[] buffer = \textcolor{keyword}{new} byte[\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}{BufferSize}}];
                \textcolor{keywordtype}{int} n;
                \textcolor{keywordflow}{while} ((n = input.Read(buffer, 0, buffer.Length)) != 0)
                \{
                    \textcolor{comment}{// could transform the data here...}
                    output.Write(buffer, 0, n);
                    \textcolor{comment}{// could update a progress bar here}
                \}
            \});

        zip.Save(zipFileName);
    \}
\}
\end{DoxyCode}
 

This example uses a named delegate in VB to write data for the given \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} (V\+B9 does not have anonymous delegates). The example here is a bit contrived -\/ a simpler way to add the contents of a file to a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} is to simply use the appropriate {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File()}}} method. The key scenario for which the {\ttfamily Write\+Delegate} makes sense is saving a Data\+Set, in X\+ML format, to the zip file. The Data\+Set can write X\+ML to a stream, and the Write\+Delegate is the perfect place to write into the zip file. There may be other data structures that can write to a stream, but cannot be read as a stream. The {\ttfamily Write\+Delegate} would be appropriate for those cases as well.


\begin{DoxyCode}
Private Sub WriteEntry (ByVal name As String, ByVal output As \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}})
    Using input As FileStream = File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)
        Dim n As Integer = -1
        Dim buffer As Byte() = New Byte(\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}{BufferSize}})\{\}
        Do While n <> 0
            n = input.Read(buffer, 0, buffer.Length)
            output.Write(buffer, 0, n)
        Loop
    End Using
End Sub

Public Sub Run()
    Using zip = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{AddEntry}}(zipEntryName, New \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a6b1de844c6db599faedbfc860c6744f6}{WriteDelegate}}(AddressOf WriteEntry))
        zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(zipFileName)
    End Using
End Sub
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca70604c3928ce13d5028d31b7d491fd}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca70604c3928ce13d5028d31b7d491fd}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a02583f9b7b1b724562c5ead6715256f2}{Open\+Delegate}}}]{opener,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a19b625523fef0bcff4722ebb8a04b5d0}{Close\+Delegate}}}]{closer }\end{DoxyParamCaption})}



Add an entry, for which the application will provide a stream containing the entry data, on a just-\/in-\/time basis. 

In cases where the application wishes to open the stream that holds the content for the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}, on a just-\/in-\/time basis, the application can use this method. The application provides an opener delegate that will be called by the Dot\+Net\+Zip library to obtain a readable stream that can be read to get the bytes for the given entry. Typically, this delegate opens a stream. Optionally, the application can provide a closer delegate as well, which will be called by Dot\+Net\+Zip when all bytes have been read from the entry. 

These delegates are called from within the scope of the call to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

This example uses anonymous methods in C\# to open and close the source stream for the content for a zip entry.


\begin{DoxyCode}
\textcolor{keyword}{using}(Ionic.Zip.ZipFile zip = \textcolor{keyword}{new} Ionic.Zip.ZipFile())
\{
    zip.AddEntry(zipEntryName,
                 (name) =>  File.Open(filename, FileMode.Open, FileAccess.Read, FileShare.ReadWrite ),
                 (name, stream) =>  stream.Close()
                 );

    zip.Save(zipFileName);
\}
\end{DoxyCode}


This example uses delegates in V\+B.\+N\+ET to open and close the the source stream for the content for a zip entry. VB 9.\+0 lacks support for \char`\"{}\+Sub\char`\"{} lambda expressions, and so the Close\+Delegate must be an actual, named Sub.


\begin{DoxyCode}
Function MyStreamOpener(ByVal entryName As String) As \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}
    \textcolor{stringliteral}{''} This simply opens a file.  You probably want to \textcolor{keywordflow}{do} somethinig
    \textcolor{stringliteral}{''} more involved here: open a stream to read from a database,
    \textcolor{stringliteral}{''} open a stream on an HTTP connection, and so on.
    Return File.OpenRead(entryName)
End Function

Sub MyStreamCloser(entryName As String, stream As \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}})
    stream.Close()
End Sub

Public Sub Run()
    Dim dirToZip As String = "fodder"
    Dim zipFileToCreate As String = "Archive.zip"
    Dim opener As \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a02583f9b7b1b724562c5ead6715256f2}{OpenDelegate}} = AddressOf MyStreamOpener
    Dim closer As \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a19b625523fef0bcff4722ebb8a04b5d0}{CloseDelegate}} = AddressOf MyStreamCloser
    Dim numFilestoAdd As Int32 = 4
    Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        Dim i As Integer
        For i = 0 To numFilesToAdd - 1
            zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{AddEntry}}(String.Format("content-\{0:000\}.txt\textcolor{stringliteral}{"), opener, closer)}
\textcolor{stringliteral}{        Next i}
\textcolor{stringliteral}{        zip.Save(zipFileToCreate)}
\textcolor{stringliteral}{    End Using}
\textcolor{stringliteral}{End Sub}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & the name of the entry to add\\
\hline
{\em opener} & the delegate that will be invoked by \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} to get the readable stream for the given entry. \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} will call read on this stream to obtain the data for the entry. This data will then be compressed and written to the newly created zip file. \\
\hline
{\em closer} & the delegate that will be invoked to close the stream. This may be null (Nothing in VB), in which case no call is makde to close the stream. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adfff34d116111c6f10073e4fa77e715d}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adfff34d116111c6f10073e4fa77e715d}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Entry@{Add\+Entry}}
\index{Add\+Entry@{Add\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Entry()}{AddEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{byte \mbox{[}$\,$\mbox{]}}]{byte\+Content }\end{DoxyParamCaption})}



Add an entry into the zip archive using the given filename and directory path within the archive, and the given content for the file. No file is created in the filesystem. 


\begin{DoxyParams}{Parameters}
{\em byte\+Content} & The data to use for the entry.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+File@{Add\+File}}
\index{Add\+File@{Add\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+File()}{AddFile()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})}



Adds a File to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. 

This call collects metadata for the named file in the filesystem, including the file attributes and the timestamp, and inserts that metadata into the resulting \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}. Only when the application calls \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, does Dot\+Net\+Zip read the file from the filesystem and then write the content to the zip file archive. 

This method will throw an exception if an entry with the same name already exists in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

In this example, three files are added to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. The Read\+Me.\+txt file will be placed in the root of the archive. The .png file will be placed in a folder within the zip called photos. The pdf file will be included into a folder within the zip called Desktop. 


\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
  \textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)photos\(\backslash\)\(\backslash\)personal\(\backslash\)\(\backslash\)7440-N49th.png"});
    zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)Desktop\(\backslash\)\(\backslash\)2008-Regional-Sales-Report.pdf"});
    zip.AddFile(\textcolor{stringliteral}{"ReadMe.txt"});

    zip.Save(\textcolor{stringliteral}{"Package.zip"});
  \}
\}
\textcolor{keywordflow}{catch} (\mbox{\hyperlink{namespace_system}{System}}.Exception ex1)
\{
  \mbox{\hyperlink{namespace_system}{System}}.Console.Error.WriteLine(\textcolor{stringliteral}{"exception: "} + ex1);
\}
\end{DoxyCode}



\begin{DoxyCode}
Try
     Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
         zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)photos\(\backslash\)personal\(\backslash\)7440-N49th.png"})
         zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)Desktop\(\backslash\)2008-Regional-Sales-Report.pdf"})
         zip.AddFile(\textcolor{stringliteral}{"ReadMe.txt"})
         zip.Save(\textcolor{stringliteral}{"Package.zip"})
     End Using
 Catch ex1 As Exception
     Console.Error.WriteLine(\textcolor{stringliteral}{"exception: \{0\}"}, ex1.ToString)
 End Try
\end{DoxyCode}
 

$<$overloads$>$This method has two overloads.$<$/overloads$>$

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}{Ionic.\+Zip.\+Zip\+File.\+Update\+File(string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file to add. It should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the File added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a265dc7dabc22f57400b3b8c8c2ce43c2}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a265dc7dabc22f57400b3b8c8c2ce43c2}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+File@{Add\+File}}
\index{Add\+File@{Add\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+File()}{AddFile()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds a File to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive, potentially overriding the path to be used within the zip archive. 

The file added by this call to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} is not written to the zip file archive until the application calls \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

This method will throw an exception if an entry with the same name already exists in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

This version of the method allows the caller to explicitly specify the directory path to be used in the archive. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

In this example, three files are added to a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. The Read\+Me.\+txt file will be placed in the root of the archive. The .png file will be placed in a folder within the zip called images. The pdf file will be included into a folder within the zip called files, and will be encrypted with the given password. 


\begin{DoxyCode}
\textcolor{keywordflow}{try}
\{
  \textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    \textcolor{comment}{// the following entry will be inserted at the root in the archive.}
    zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)datafiles\(\backslash\)\(\backslash\)ReadMe.txt"}, \textcolor{stringliteral}{""});
    \textcolor{comment}{// this image file will be inserted into the "images" directory in the archive.}
    zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)photos\(\backslash\)\(\backslash\)personal\(\backslash\)\(\backslash\)7440-N49th.png"}, \textcolor{stringliteral}{"images"});
    \textcolor{comment}{// the following will result in a password-protected file called}
    \textcolor{comment}{// files\(\backslash\)\(\backslash\)docs\(\backslash\)\(\backslash\)2008-Regional-Sales-Report.pdf  in the archive.}
    zip.Password = \textcolor{stringliteral}{"EncryptMe!"};
    zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)Desktop\(\backslash\)\(\backslash\)2008-Regional-Sales-Report.pdf"}, \textcolor{stringliteral}{"files\(\backslash\)\(\backslash\)docs"});
    zip.Save(\textcolor{stringliteral}{"Archive.zip"});
  \}
\}
\textcolor{keywordflow}{catch} (\mbox{\hyperlink{namespace_system}{System}}.Exception ex1)
\{
  \mbox{\hyperlink{namespace_system}{System}}.Console.Error.WriteLine(\textcolor{stringliteral}{"exception: \{0\}"}, ex1);
\}
\end{DoxyCode}



\begin{DoxyCode}
Try
    Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        \textcolor{stringliteral}{' the following entry will be inserted at the root in the archive.}
\textcolor{stringliteral}{        zip.AddFile("c:\(\backslash\)datafiles\(\backslash\)ReadMe.txt", "")}
\textcolor{stringliteral}{        '} \textcolor{keyword}{this} image file will be inserted into the \textcolor{stringliteral}{"images"} directory in the archive.
        zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)photos\(\backslash\)personal\(\backslash\)7440-N49th.png"}, \textcolor{stringliteral}{"images"})
        \textcolor{stringliteral}{' the following will result in a password-protected file called}
\textcolor{stringliteral}{        '} files\(\backslash\)\(\backslash\)docs\(\backslash\)\(\backslash\)2008-Regional-Sales-Report.pdf  in the archive.
        zip.Password = \textcolor{stringliteral}{"EncryptMe!"}
        zip.AddFile(\textcolor{stringliteral}{"c:\(\backslash\)Desktop\(\backslash\)2008-Regional-Sales-Report.pdf"}, \textcolor{stringliteral}{"files\(\backslash\)documents"})
        zip.Save(\textcolor{stringliteral}{"Archive.zip"})
    End Using
Catch ex1 As Exception
    Console.Error.WriteLine(\textcolor{stringliteral}{"exception: \{0\}"}, ex1)
End Try
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string,string), \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string, string)}}, Ionic.\+Zip.\+Zip\+File.\+Update\+File(string,string)


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file to add. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the file\+Name. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on the file\+Name, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the file added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aec731f8e3920d0028fc746c7b71e60a7}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aec731f8e3920d0028fc746c7b71e60a7}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Files@{Add\+Files}}
\index{Add\+Files@{Add\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Files()}{AddFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Files (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$}]{file\+Names }\end{DoxyParamCaption})}



This method adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

Use this method to add a set of files to the zip archive, in one call. For example, a list of files received from {\ttfamily System.\+I\+O.\+Directory.\+Get\+Files()} can be added to a zip archive in one call. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 


\begin{DoxyParams}{Parameters}
{\em file\+Names} & The collection of names of the files to add. Each string should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}


This example shows how to create a zip file, and add a few files into it. 
\begin{DoxyCode}
String ZipFileToCreate = \textcolor{stringliteral}{"archive1.zip"};
String DirectoryToZip = \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)reports"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  \textcolor{comment}{// Store all files found in the top level directory, into the zip archive.}
  String[] filenames = \mbox{\hyperlink{namespace_system}{System}}.IO.Directory.GetFiles(DirectoryToZip);
  zip.AddFiles(filenames);
  zip.Save(ZipFileToCreate);
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim ZipFileToCreate As String = \textcolor{stringliteral}{"archive1.zip"}
Dim DirectoryToZip As String = \textcolor{stringliteral}{"c:\(\backslash\)reports"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    \textcolor{stringliteral}{' Store all files found in the top level directory, into the zip archive.}
\textcolor{stringliteral}{    Dim filenames As String() = System.IO.Directory.GetFiles(DirectoryToZip)}
\textcolor{stringliteral}{    zip.AddFiles(filenames)}
\textcolor{stringliteral}{    zip.Save(ZipFileToCreate)}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}{Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files(\+String, String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a93ca8dfa47090d70efdd86f6960f42a9}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a93ca8dfa47090d70efdd86f6960f42a9}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Files@{Add\+Files}}
\index{Add\+Files@{Add\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Files()}{AddFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Files (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$}]{file\+Names,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive. 

Any directory structure that may be present in the filenames contained in the list is \char`\"{}flattened\char`\"{} in the archive. Each file in the list is added to the archive in the specified top-\/level directory. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 


\begin{DoxyParams}{Parameters}
{\em file\+Names} & The names of the files to add. Each string should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the file name. Th is path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on each of the {\ttfamily file\+Names}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}{Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files(\+String, String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5f0daa18dd5b12972b572d2dae1af918}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5f0daa18dd5b12972b572d2dae1af918}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Files@{Add\+Files}}
\index{Add\+Files@{Add\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Files()}{AddFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Files (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$}]{file\+Names,  }\item[{bool}]{preserve\+Dir\+Hierarchy,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive, and preserving the full directory structure in the filenames. 

Think of the {\itshape directory\+Path\+In\+Archive}  as a \char`\"{}root\char`\"{} or base directory used in the archive for the files that get added. when {\itshape preserve\+Dir\+Hierarchy}  is true, the hierarchy of files found in the filesystem will be placed, with the hierarchy intact, starting at that root in the archive. When {\ttfamily preserve\+Dir\+Hierarchy} is false, the path hierarchy of files is flattned, and the flattened set of files gets placed in the root within the archive as specified in {\ttfamily directory\+Path\+In\+Archive}. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 


\begin{DoxyParams}{Parameters}
{\em file\+Names} & The names of the files to add. Each string should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use as a prefix for each entry name. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on each of the {\ttfamily file\+Names}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em preserve\+Dir\+Hierarchy} & whether the entries in the zip archive will reflect the directory hierarchy that is present in the various filenames. For example, if {\itshape file\+Names}  includes two paths, .txt and .txt, then calling this method with {\itshape preserve\+Dir\+Hierarchy}  = {\ttfamily false} will result in an exception because of a duplicate entry name, while calling this method with {\itshape preserve\+Dir\+Hierarchy}  = {\ttfamily true} will result in the full direcory paths being included in the entries added to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}{Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files(\+String, String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Item@{Add\+Item}}
\index{Add\+Item@{Add\+Item}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Item()}{AddItem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Item (\begin{DoxyParamCaption}\item[{string}]{file\+Or\+Directory\+Name }\end{DoxyParamCaption})}



Adds an item, either a file or a directory, to a zip file archive. 

This method is handy if you are adding things to zip archive and don\textquotesingle{}t want to bother distinguishing between directories or files. Any files are added as single entries. A directory added through this method is added recursively\+: all files and subdirectories contained within the directory are added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

The name of the item may be a relative path or a fully-\/qualified path. Remember, the items contained in {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance get written to the disk only when you call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} or a similar save method. 

The directory name used for the file within the archive is the same as the directory name (potentially a relative path) specified in the {\itshape file\+Or\+Directory\+Name} . 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Ionic.\+Zip.\+Zip\+File.\+Add\+File(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string)}}


\end{DoxySeeAlso}


$<$overloads$>$This method has two overloads.$<$/overloads$>$ 
\begin{DoxyParams}{Parameters}
{\em file\+Or\+Directory\+Name} & the name of the file or directory to add.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4f5b34dc261ef4f4af63d0a692d9cfc6}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4f5b34dc261ef4f4af63d0a692d9cfc6}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Item@{Add\+Item}}
\index{Add\+Item@{Add\+Item}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Item()}{AddItem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Item (\begin{DoxyParamCaption}\item[{String}]{file\+Or\+Directory\+Name,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds an item, either a file or a directory, to a zip file archive, explicitly specifying the directory path to be used in the archive. 

If adding a directory, the add is recursive on all files and subdirectories contained within it. 

The name of the item may be a relative path or a fully-\/qualified path. The item added by this call to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} is not read from the disk nor written to the zip file archive until the application calls \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

This version of the method allows the caller to explicitly specify the directory path to be used in the archive, which would override the \char`\"{}natural\char`\"{} path of the filesystem file. 

Encryption will be used on the file data if the {\ttfamily Password} has been set on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} object, prior to calling this method. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+I\+O.\+File\+Not\+Found\+Exception} & Thrown if the file or directory passed in does not exist. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Or\+Directory\+Name} & the name of the file or directory to add. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & The name of the directory path to use within the zip archive. This path need not refer to an extant directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on the file\+Or\+Directory\+Name. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+File(string, string), \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string, string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string, string)}}


\end{DoxySeeAlso}


This example shows how to zip up a set of files into a flat hierarchy, regardless of where in the filesystem the files originated. The resulting zip archive will contain a toplevel directory named \char`\"{}flat\char`\"{}, which itself will contain files Readme.\+txt, My\+Proposal.\+docx, and Image1.\+jpg. A subdirectory under \char`\"{}flat\char`\"{} called Support\+Files will contain all the files in the \char`\"{}c\+:\textbackslash{}\+Support\+Files\char`\"{} directory on disk.


\begin{DoxyCode}
String[] itemnames= \{
  \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)fixedContent\(\backslash\)\(\backslash\)Readme.txt"},
  \textcolor{stringliteral}{"MyProposal.docx"},
  \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)SupportFiles"},  \textcolor{comment}{// a directory}
  \textcolor{stringliteral}{"images\(\backslash\)\(\backslash\)Image1.jpg"}
\};

\textcolor{keywordflow}{try}
\{
  \textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i < itemnames.Length; i++)
    \{
      \textcolor{comment}{// will add Files or Dirs, recurses and flattens subdirectories}
      zip.AddItem(itemnames[i],\textcolor{stringliteral}{"flat"});
    \}
    zip.Save(ZipToCreate);
  \}
\}
\textcolor{keywordflow}{catch} (\mbox{\hyperlink{namespace_system}{System}}.Exception ex1)
\{
  \mbox{\hyperlink{namespace_system}{System}}.Console.Error.WriteLine(\textcolor{stringliteral}{"exception: \{0\}"}, ex1);
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim itemnames As String() = \_
  New String() \{ \textcolor{stringliteral}{"c:\(\backslash\)fixedContent\(\backslash\)Readme.txt"}, \_
                 \textcolor{stringliteral}{"MyProposal.docx"}, \_
                 \textcolor{stringliteral}{"SupportFiles"}, \_
                 \textcolor{stringliteral}{"images\(\backslash\)Image1.jpg"} \}
Try
    Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        Dim i As Integer
        For i = 1 To itemnames.Length - 1
            \textcolor{stringliteral}{' will add Files or Dirs, recursing and flattening subdirectories.}
\textcolor{stringliteral}{            zip.AddItem(itemnames(i), "flat")}
\textcolor{stringliteral}{        Next i}
\textcolor{stringliteral}{        zip.Save(ZipToCreate)}
\textcolor{stringliteral}{    End Using}
\textcolor{stringliteral}{Catch ex1 As Exception}
\textcolor{stringliteral}{    Console.Error.WriteLine("exception: \{0\}", ex1.ToString())}
\textcolor{stringliteral}{End Try}
\end{DoxyCode}
 

\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the current working directory on disk, that conform to the specified criteria. 

This method selects files from the the current working directory matching the specified criteria, and adds them to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

Specify the criteria in statements of 3 elements\+: a noun, an operator, and a value. Consider the string \char`\"{}name != $\ast$.\+doc\char`\"{} . The noun is \char`\"{}name\char`\"{}. The operator is \char`\"{}!=\char`\"{}, implying \char`\"{}\+Not Equal\char`\"{}. The value is \char`\"{}$\ast$.\+doc\char`\"{}. That criterion, in English, says \char`\"{}all files with a name that does not end in
  the .\+doc extension.\char`\"{} 

Supported nouns include \char`\"{}name\char`\"{} (or \char`\"{}filename\char`\"{}) for the filename; \char`\"{}atime\char`\"{}, \char`\"{}mtime\char`\"{}, and \char`\"{}ctime\char`\"{} for last access time, last modfied time, and created time of the file, respectively; \char`\"{}attributes\char`\"{} (or \char`\"{}attrs\char`\"{}) for the file attributes; \char`\"{}size\char`\"{} (or \char`\"{}length\char`\"{}) for the file length (uncompressed), and \char`\"{}type\char`\"{} for the type of object, either a file or a directory. The \char`\"{}attributes\char`\"{}, \char`\"{}name\char`\"{} and \char`\"{}type\char`\"{} nouns both support = and != as operators. The \char`\"{}size\char`\"{}, \char`\"{}atime\char`\"{}, \char`\"{}mtime\char`\"{}, and \char`\"{}ctime\char`\"{} nouns support = and !=, and $>$, $>$=, $<$, $<$= as well. The times are taken to be expressed in local time. 

Specify values for the file attributes as a string with one or more of the characters H,R,S,A,I,L in any order, implying file attributes of Hidden, Read\+Only, System, Archive, Not\+Context\+Indexed, and Reparse\+Point (symbolic link) respectively. 

To specify a time, use Y\+Y\+Y\+Y-\/\+M\+M-\/\+D\+D-\/\+HH\+:mm\+:ss or Y\+Y\+Y\+Y/\+M\+M/\+D\+D-\/\+HH\+:mm\+:ss as the format. If you omit the H\+H\+:mm\+:ss portion, it is assumed to be 00\+:00\+:00 (midnight). 

The value for a size criterion is expressed in integer quantities of bytes, kilobytes (use k or kb after the number), megabytes (m or mb), or gigabytes (g or gb). 

The value for a name is a pattern to match against the filename, potentially including wildcards. The pattern follows C\+M\+D.\+exe glob rules\+: $\ast$ implies one or more of any character, while ? implies one character. If the name pattern contains any slashes, it is matched to the entire filename, including the path; otherwise, it is matched against only the filename without the path. This means a pattern of \char`\"{}$\ast$\textbackslash{}$\ast$.$\ast$\char`\"{} matches all files one directory level deep, while a pattern of \char`\"{}$\ast$.$\ast$\char`\"{} matches all files in all directories. 

To specify a name pattern that includes spaces, use single quotes around the pattern. A pattern of \char`\"{}\textquotesingle{}$\ast$ $\ast$.$\ast$\textquotesingle{}\char`\"{} will match all files that have spaces in the filename. The full criteria string for that would be \char`\"{}name = \textquotesingle{}$\ast$ $\ast$.$\ast$\textquotesingle{}\char`\"{} . 

The value for a type criterion is either F (implying a file) or D (implying a directory). 

Some examples\+: 

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ criteria }&\textbf{ Files retrieved 

}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ criteria }&\textbf{ Files retrieved 

}\\\cline{1-2}
\endhead
name != $\ast$.xls  &any file with an extension that is not .xls  

\\\cline{1-2}
name = $\ast$.mp3  &any file with a .mp3 extension.  

\\\cline{1-2}
$\ast$.mp3 &(same as above) any file with a .mp3 extension.  

\\\cline{1-2}
attributes = A  &all files whose attributes include the Archive bit.  

\\\cline{1-2}
attributes != H  &all files whose attributes do not include the Hidden bit.  

\\\cline{1-2}
mtime $>$ 2009-\/01-\/01 &all files with a last modified time after January 1st, 2009.  

\\\cline{1-2}
size $>$ 2gb &all files whose uncompressed size is greater than 2gb.  

\\\cline{1-2}
type = D &all directories in the filesystem.  

\\\cline{1-2}
\end{longtabu}


You can combine criteria with the conjunctions A\+ND or OR. Using a string like \char`\"{}name = $\ast$.\+txt A\+N\+D size >= 100k\char`\"{} for the selection\+Criteria retrieves entries whose names end in .txt, and whose uncompressed size is greater than or equal to 100 kilobytes. 

For more complex combinations of criteria, you can use parenthesis to group clauses in the boolean logic. Without parenthesis, the precedence of the criterion atoms is determined by order of appearance. Unlike the C\# language, the A\+ND conjunction does not take precendence over the logical OR. This is important only in strings that contain 3 or more criterion atoms. In other words, \char`\"{}name = $\ast$.\+txt and size > 1000 or attributes = H\char`\"{} implies \char`\"{}((name = $\ast$.\+txt A\+N\+D size > 1000) O\+R attributes = H)\char`\"{} while \char`\"{}attributes =
\+H O\+R name = $\ast$.\+txt and size > 1000\char`\"{} evaluates to \char`\"{}((attributes = H O\+R name
= $\ast$.\+txt) A\+N\+D size > 1000)\char`\"{}. When in doubt, use parenthesis. 

Using time properties requires some extra care. If you want to retrieve all entries that were last updated on 2009 February 14, specify a time range like so\+:\char`\"{}mtime >= 2009-\/02-\/14 A\+N\+D mtime < 2009-\/02-\/15\char`\"{}. Read this to say\+: all files updated after 12\+:00am on February 14th, until 12\+:00am on February 15th. You can use the same bracketing approach to specify any time period -\/ a year, a month, a week, and so on. 

The syntax allows one special case\+: if you provide a string with no spaces, it is treated as a pattern to match for the filename. Therefore a string like \char`\"{}$\ast$.\+xls\char`\"{} will be equivalent to specifying \char`\"{}name = $\ast$.\+xls\char`\"{}. 

There is no logic in this method that insures that the file inclusion criteria are internally consistent. For example, it\textquotesingle{}s possible to specify criteria that says the file must have a size of less than 100 bytes, as well as a size that is greater than 1000 bytes. Obviously no file will ever satisfy such criteria, but this method does not detect such logical inconsistencies. The caller is responsible for insuring the criteria are sensible. 

Using this method, the file selection does not recurse into subdirectories, and the full path of the selected files is included in the entries added into the zip archive. If you don\textquotesingle{}t like these behaviors, see the other overloads of this method. 

This example zips up all $\ast$.csv files in the current working directory. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// To just match on filename wildcards,}
    \textcolor{comment}{// use the shorthand form of the selectionCriteria string.}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"*.csv"});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{AddSelectedFiles}}("*.csv")
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(PathToZipArchive)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for file selection\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad870726d9ab09168d2f1525fd61826bb}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad870726d9ab09168d2f1525fd61826bb}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{bool}]{recurse\+Directories }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the disk that conform to the specified criteria, optionally recursing into subdirectories. 

This method selects files from the the current working directory matching the specified criteria, and adds them to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. If {\ttfamily recurse\+Directories} is true, files are also selected from subdirectories, and the directory structure in the filesystem is reproduced in the zip archive, rooted at the current working directory. 

Using this method, the full path of the selected files is included in the entries added into the zip archive. If you don\textquotesingle{}t want this behavior, use one of the overloads of this method that allows the specification of a {\ttfamily directory\+In\+Archive}. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example zips up all $\ast$.xml files in the current working directory, or any subdirectory, that are larger than 1mb.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// Use a compound expression in the selectionCriteria string.}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name = *.xml  and  size > 1024kb"}, \textcolor{keyword}{true});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    \textcolor{stringliteral}{' Use a compound expression in the selectionCriteria string.}
\textcolor{stringliteral}{    zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", true)}
\textcolor{stringliteral}{    zip.Save(PathToZipArchive)}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for file selection\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em recurse\+Directories} & If true, the file selection will recurse into subdirectories. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+On\+Disk }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from a specified directory in the filesystem, that conform to the specified criteria. 

This method selects files that conform to the specified criteria, from the the specified directory on disk, and adds them to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. The search does not recurse into subdirectores. 

Using this method, the full filesystem path of the files on disk is reproduced on the entries added to the zip file. If you don\textquotesingle{}t want this behavior, use one of the other overloads of this method. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example zips up all $\ast$.xml files larger than 1mb in the directory given by \char`\"{}d\+:\textbackslash{}rawdata\char`\"{}.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// Use a compound expression in the selectionCriteria string.}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name = *.xml  and  size > 1024kb"}, \textcolor{stringliteral}{"d:\(\backslash\)\(\backslash\)rawdata"});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    \textcolor{stringliteral}{' Use a compound expression in the selectionCriteria string.}
\textcolor{stringliteral}{    zip.AddSelectedFiles("name = *.xml  and  size > 1024kb", "d:\(\backslash\)rawdata)}
\textcolor{stringliteral}{    zip.Save(PathToZipArchive)}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for file selection\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+On\+Disk} & The name of the directory on the disk from which to select files. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a501b507514805d3e5f1024315a771332}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a501b507514805d3e5f1024315a771332}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+On\+Disk,  }\item[{bool}]{recurse\+Directories }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a set of files from the specified directory on disk, that conform to the specified criteria. 

This method selects files from the the specified disk directory matching the specified selection criteria, and adds them to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. If {\ttfamily recurse\+Directories} is true, files are also selected from subdirectories. 

The full directory structure in the filesystem is reproduced on the entries added to the zip archive. If you don\textquotesingle{}t want this behavior, use one of the overloads of this method that allows the specification of a {\ttfamily directory\+In\+Archive}. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example zips up all $\ast$.csv files in the \char`\"{}files\char`\"{} directory, or any subdirectory, that have been saved since 2009 February 14th.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// Use a compound expression in the selectionCriteria string.}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name = *.csv  and  mtime > 2009-02-14"}, \textcolor{stringliteral}{"files"}, \textcolor{keyword}{true});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    \textcolor{stringliteral}{' Use a compound expression in the selectionCriteria string.}
\textcolor{stringliteral}{    zip.AddSelectedFiles("name = *.csv  and  mtime > 2009-02-14", "files", true)}
\textcolor{stringliteral}{    zip.Save(PathToZipArchive)}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 

This example zips up all files in the current working directory, and all its child directories, except those in the {\ttfamily excludethis} subdirectory. 
\begin{DoxyCode}
Using Zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}(zipfile)
  Zip.AddSelectedFfiles(\textcolor{stringliteral}{"name != 'excludethis\(\backslash\)*.*'"}, datapath, True)
  Zip.Save()
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for file selection\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+On\+Disk} & The filesystem path from which to select files. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em recurse\+Directories} & If true, the file selection will recurse into subdirectories. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac91a94eb12f9285dfb84c1414bb8214e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac91a94eb12f9285dfb84c1414bb8214e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+On\+Disk,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a selection of files from the specified directory on disk, that conform to the specified criteria, and using a specified root path for entries added to the zip archive. 

This method selects files from the specified disk directory matching the specified selection criteria, and adds those files to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, using the specified directory path in the archive. The search does not recurse into subdirectories. For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example zips up all $\ast$.psd files in the \char`\"{}photos\char`\"{} directory that have been saved since 2009 February 14th, and puts them all in a zip file, using the directory name of \char`\"{}content\char`\"{} in the zip archive itself. When the zip archive is unzipped, the folder containing the .psd files will be named \char`\"{}content\char`\"{}.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// Use a compound expression in the selectionCriteria string.}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name = *.psd  and  mtime > 2009-02-14"}, \textcolor{stringliteral}{"photos"}, \textcolor{stringliteral}{"content"});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name = *.psd  and  mtime > 2009-02-14"}, \textcolor{stringliteral}{"photos"}, \textcolor{stringliteral}{"content"})
    zip.Save(PathToZipArchive)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for selection of files to add to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+On\+Disk} & The path to the directory in the filesystem from which to select files. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to in place of the {\ttfamily directory\+On\+Disk}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing null (nothing in VB) will use the path on the file name, if any; in other words it would use {\ttfamily directory\+On\+Disk}, plus any subdirectory. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a95106f452f2326adb48fc72d1450a15e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a95106f452f2326adb48fc72d1450a15e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Selected\+Files@{Add\+Selected\+Files}}
\index{Add\+Selected\+Files@{Add\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Selected\+Files()}{AddSelectedFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+On\+Disk,  }\item[{String}]{directory\+Path\+In\+Archive,  }\item[{bool}]{recurse\+Directories }\end{DoxyParamCaption})}



Adds to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} a selection of files from the specified directory on disk, that conform to the specified criteria, optionally recursing through subdirectories, and using a specified root path for entries added to the zip archive. 

This method selects files from the specified disk directory that match the specified selection criteria, and adds those files to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, using the specified directory path in the archive. If {\ttfamily recurse\+Directories} is true, files are also selected from subdirectories, and the directory structure in the filesystem is reproduced in the zip archive, rooted at the directory specified by {\ttfamily directory\+On\+Disk}. For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example zips up all files that are N\+OT $\ast$.pst files, in the current working directory and any subdirectories.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name != *.pst"}, SourceDirectory, \textcolor{stringliteral}{"backup"}, \textcolor{keyword}{true});
    zip.Save(PathToZipArchive);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip.AddSelectedFiles(\textcolor{stringliteral}{"name != *.pst"}, SourceDirectory, \textcolor{stringliteral}{"backup"}, \textcolor{keyword}{true})
    zip.Save(PathToZipArchive)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for selection of files to add to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+On\+Disk} & The path to the directory in the filesystem from which to select files. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to in place of the {\ttfamily directory\+On\+Disk}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing null (nothing in VB) will use the path on the file name, if any; in other words it would use {\ttfamily directory\+On\+Disk}, plus any subdirectory. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em recurse\+Directories} & If true, the method also scans subdirectories for files matching the criteria. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a25223986c875661870fa62d08d68ef45}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a25223986c875661870fa62d08d68ef45}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Check\+Zip@{Check\+Zip}}
\index{Check\+Zip@{Check\+Zip}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Check\+Zip()}{CheckZip()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Check\+Zip (\begin{DoxyParamCaption}\item[{string}]{zip\+File\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks a zip file to see if its directory is consistent. 

In cases of data error, the directory within a zip file can get out of synch with the entries in the zip file. This method checks the given zip file and returns true if this has occurred. 

This method may take a long time to run for large zip files. 

This method is not supported in the Reduced or Compact Framework versions of Dot\+Net\+Zip. 

Developers using C\+OM can use the \mbox{\hyperlink{}{Com\+Helper.\+Check\+Zip(\+String)}} method. 


\begin{DoxyParams}{Parameters}
{\em zip\+File\+Name} & The filename to of the zip file to check.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
true if the named zip file checks OK. Otherwise, false. 
\end{DoxyReturn}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca101c62532b74ff851ba8f18e0c9091}{Fix\+Zip\+Directory(string)}}, Check\+Zip(string,bool,\+System.\+I\+O.\+Text\+Writer)


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a74ae77bf0b002c61ffe54815d405adec}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a74ae77bf0b002c61ffe54815d405adec}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Check\+Zip@{Check\+Zip}}
\index{Check\+Zip@{Check\+Zip}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Check\+Zip()}{CheckZip()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Check\+Zip (\begin{DoxyParamCaption}\item[{string}]{zip\+File\+Name,  }\item[{bool}]{fix\+If\+Necessary,  }\item[{Text\+Writer}]{writer }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks a zip file to see if its directory is consistent, and optionally fixes the directory if necessary. 

In cases of data error, the directory within a zip file can get out of synch with the entries in the zip file. This method checks the given zip file, and returns true if this has occurred. It also optionally fixes the zipfile, saving the fixed copy in {\itshape Name}\+\_\+\+Fixed.\+zip. 

This method may take a long time to run for large zip files. It will take even longer if the file actually needs to be fixed, and if {\ttfamily fix\+If\+Necessary} is true. 

This method is not supported in the Reduced or Compact Framework versions of Dot\+Net\+Zip. 


\begin{DoxyParams}{Parameters}
{\em zip\+File\+Name} & The filename to of the zip file to check.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em fix\+If\+Necessary} & If true, the method will fix the zip file if necessary.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em writer} & a Text\+Writer in which messages generated while checking will be written. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
true if the named zip is OK; false if the file needs to be fixed.
\end{DoxyReturn}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a25223986c875661870fa62d08d68ef45}{Check\+Zip(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca101c62532b74ff851ba8f18e0c9091}{Fix\+Zip\+Directory(string)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abb1bba30c02b71822a1053fa5f4a8204}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abb1bba30c02b71822a1053fa5f4a8204}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Check\+Zip\+Password@{Check\+Zip\+Password}}
\index{Check\+Zip\+Password@{Check\+Zip\+Password}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Check\+Zip\+Password()}{CheckZipPassword()}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Check\+Zip\+Password (\begin{DoxyParamCaption}\item[{string}]{zip\+File\+Name,  }\item[{string}]{password }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Verify the password on a zip file. 

Keep in mind that passwords in zipfiles are applied to zip entries, not to the entire zip file. So testing a zipfile for a particular password doesn\textquotesingle{}t work in the general case. On the other hand, it\textquotesingle{}s often the case that a single password will be used on all entries in a zip file. This method works for that case. 

There is no way to check a password without doing the decryption. So this code decrypts and extracts the given zipfile into System.\+I\+O.\+Stream.\+Null 


\begin{DoxyParams}{Parameters}
{\em zip\+File\+Name} & The filename to of the zip file to fix.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em password} & The password to check.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
a bool indicating whether the password matches.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae031db150a3aa82ad89e922ce2ac4840}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae031db150a3aa82ad89e922ce2ac4840}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Contains\+Entry@{Contains\+Entry}}
\index{Contains\+Entry@{Contains\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Contains\+Entry()}{ContainsEntry()}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Contains\+Entry (\begin{DoxyParamCaption}\item[{string}]{name }\end{DoxyParamCaption})}



Returns true if an entry by the given name exists in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 


\begin{DoxyParams}{Parameters}
{\em name} & the name of the entry to find\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if an entry with the given name exists; otherwise false. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Dispose@{Dispose}}
\index{Dispose@{Dispose}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Dispose()}{Dispose()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Dispose (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Closes the read and write streams associated to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, if necessary. 

The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose()}} method is generally employed implicitly, via a {\ttfamily using(..) \{..\}} statement. ({\ttfamily Using...End Using} in VB) If you do not employ a using statement, insure that your application calls \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose()}} explicitly. For example, in a Powershell application, or an application that uses the C\+OM interop interface, you must call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose()}} explicitly. 

This example extracts an entry selected by name, from the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file to the Console. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipfile))
\{
  \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} zip)
  \{
    \textcolor{keywordflow}{if} (WantThisEntry(e.FileName))
      zip.Extract(e.FileName, Console.OpenStandardOutput());
  \}
\} \textcolor{comment}{// Dispose() is called implicitly here.}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipfile)
    Dim e As ZipEntry
    For Each e In zip
      If WantThisEntry(e.FileName) Then
          zip.Extract(e.FileName, Console.OpenStandardOutput())
      End If
    Next
End Using ' \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{Dispose}} is implicity called here
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aea428408377b5d7e0487bd86bf8c1d4b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aea428408377b5d7e0487bd86bf8c1d4b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Dispose@{Dispose}}
\index{Dispose@{Dispose}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Dispose()}{Dispose()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily virtual void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Dispose (\begin{DoxyParamCaption}\item[{bool}]{dispose\+Managed\+Resources }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}



Disposes any managed resources, if the flag is set, then marks the instance disposed. This method is typically not called explicitly from application code. 

Applications should call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad1511084b1a8308d69403bb940fcaeb4}{the no-\/arg Dispose method}}. 


\begin{DoxyParams}{Parameters}
{\em dispose\+Managed\+Resources} & indicates whether the method should dispose streams or not. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acf65879aa66b0f58c5af340264b54374}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acf65879aa66b0f58c5af340264b54374}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+All@{Extract\+All}}
\index{Extract\+All@{Extract\+All}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+All()}{ExtractAll()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+All (\begin{DoxyParamCaption}\item[{string}]{path }\end{DoxyParamCaption})}



Extracts all of the items in the zip archive, to the specified path in the filesystem. The path can be relative or fully-\/qualified. 

This method will extract all entries in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} to the specified path. 

If an extraction of a file from the zip archive would overwrite an existing file in the filesystem, the action taken is dictated by the Extract\+Existing\+File property, which overrides any setting you may have made on individual \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instances. By default, if you have not set that property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance, the entry will not be extracted, the existing file will not be overwritten and an exception will be thrown. To change this, set the property, or use the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0f8bd27ce81b112d252c8cd2e1f06934}{Zip\+File.\+Extract\+All(string,
  Ionic.\+Zip.\+Extract\+Existing\+File\+Action)}} overload that allows you to specify an Extract\+Existing\+File\+Action parameter. 

The action to take when an extract would overwrite an existing file applies to all entries. If you want to set this on a per-\/entry basis, then you must use one of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9d65543aadd23e47e188175412891b42}{Zip\+Entry.\+Extract}} methods. 

This method will send verbose output messages to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}{Status\+Message\+Text\+Writer}}, if it is set on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

You may wish to take advantage of the {\ttfamily Extract\+Progress} event. 

About timestamps\+: When extracting a file entry from a zip archive, the extracted file gets the last modified time of the entry as stored in the archive. The archive may also store extended file timestamp information, including last accessed and created times. If these are present in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}, then the extracted file will also get these times. 

A Directory entry is somewhat different. It will get the times as described for a file entry, but, if there are file entries in the zip archive that, when extracted, appear in the just-\/created directory, then when those file entries are extracted, the last modified and last accessed times of the directory will change, as a side effect. The result is that after an extraction of a directory and a number of files within the directory, the last modified and last accessed timestamps on the directory will reflect the time that the last file was extracted into the directory, rather than the time stored in the zip archive for the directory. 

To compensate, when extracting an archive with {\ttfamily Extract\+All}, Dot\+Net\+Zip will extract all the file and directory entries as described above, but it will then make a second pass on the directories, and reset the times on the directories to reflect what is stored in the zip archive. 

This compensation is performed only within the context of an {\ttfamily Extract\+All}. If you call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9d65543aadd23e47e188175412891b42}{Zip\+Entry.\+Extract}}} on a directory entry, the timestamps on directory in the filesystem will reflect the times stored in the zip. If you then call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9d65543aadd23e47e188175412891b42}{Zip\+Entry.\+Extract}}} on a file entry, which is extracted into the directory, the timestamps on the directory will be updated to the current time. 

This example extracts all the entries in a zip archive file, to the specified target directory. The extraction will overwrite any existing files silently.


\begin{DoxyCode}
String TargetDirectory= \textcolor{stringliteral}{"unpack"};
\textcolor{keyword}{using}(\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip= \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToExtract))
\{
    zip.ExtractExistingFile= \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.OverwriteSilently;
    zip.ExtractAll(TargetDirectory);
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim TargetDirectory As String = \textcolor{stringliteral}{"unpack"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToExtract)
    zip.ExtractExistingFile= \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.OverwriteSilently
    zip.ExtractAll(TargetDirectory)
End Using
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{Ionic.\+Zip.\+Zip\+File.\+Extract\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Ionic.\+Zip.\+Zip\+File.\+Extract\+Existing\+File}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em path} & The path to which the contents of the zipfile will be extracted. The path can be relative or fully-\/qualified. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0f8bd27ce81b112d252c8cd2e1f06934}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0f8bd27ce81b112d252c8cd2e1f06934}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+All@{Extract\+All}}
\index{Extract\+All@{Extract\+All}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+All()}{ExtractAll()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+All (\begin{DoxyParamCaption}\item[{string}]{path,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}}}]{extract\+Existing\+File }\end{DoxyParamCaption})}



Extracts all of the items in the zip archive, to the specified path in the filesystem, using the specified behavior when extraction would overwrite an existing file. 

This method will extract all entries in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} to the specified path. For an extraction that would overwrite an existing file, the behavior is dictated by {\itshape extract\+Existing\+File} , which overrides any setting you may have made on individual \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instances. 

The action to take when an extract would overwrite an existing file applies to all entries. If you want to set this on a per-\/entry basis, then you must use Zip\+Entry.\+Extract(\+String,
\+Extract\+Existing\+File\+Action) or one of the similar methods. 

Calling this method is equivalent to setting the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}} property and then calling Extract\+All(\+String). 

This method will send verbose output messages to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}{Status\+Message\+Text\+Writer}}, if it is set on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

This example extracts all the entries in a zip archive file, to the specified target directory. It does not overwrite any existing files. 
\begin{DoxyCode}
String TargetDirectory= \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)unpack"};
\textcolor{keyword}{using}(\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip= \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToExtract))
\{
  zip.ExtractAll(TargetDirectory, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.DontOverwrite);
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim TargetDirectory As String = \textcolor{stringliteral}{"c:\(\backslash\)unpack"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToExtract)
    zip.ExtractAll(TargetDirectory, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.DontOverwrite)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em path} & The path to which the contents of the zipfile will be extracted. The path can be relative or fully-\/qualified. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em extract\+Existing\+File} & The action to take if extraction would overwrite an existing file. \\
\hline
\end{DoxyParams}
\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ace7e25684ee440ee2dfda5012e64d137}{Extract\+Selected\+Entries(\+String,\+Extract\+Existing\+File\+Action)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1c3f402c719453b86bec0438b649c5f4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1c3f402c719453b86bec0438b649c5f4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Selected\+Entries@{Extract\+Selected\+Entries}}
\index{Extract\+Selected\+Entries@{Extract\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Selected\+Entries()}{ExtractSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [1/5]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria }\end{DoxyParamCaption})}



Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The entries are extracted into the current working directory. 

If any of the files to be extracted already exist, then the action taken is as specified in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_ad1ab903c29b91edb82e7c6a9768552dd}{Zip\+Entry.\+Extract\+Existing\+File}} property on the corresponding \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instance. By default, the action taken in this case is to throw an exception. 

For information on the syntax of the selection\+Criteria string, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example shows how extract all X\+ML files modified after 15 January 2009. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipArchiveName))
\{
  zip.ExtractSelectedEntries(\textcolor{stringliteral}{"name = *.xml  and  mtime > 2009-01-15"});
\}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the selection criteria for entries to extract.\\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ace7e25684ee440ee2dfda5012e64d137}{Extract\+Selected\+Entries(\+String,\+Extract\+Existing\+File\+Action)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ace7e25684ee440ee2dfda5012e64d137}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ace7e25684ee440ee2dfda5012e64d137}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Selected\+Entries@{Extract\+Selected\+Entries}}
\index{Extract\+Selected\+Entries@{Extract\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Selected\+Entries()}{ExtractSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [2/5]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}}}]{extract\+Existing\+File }\end{DoxyParamCaption})}



Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The entries are extracted into the current working directory. When extraction would would overwrite an existing filesystem file, the action taken is as specified in the {\itshape extract\+Existing\+File}  parameter. 

For information on the syntax of the string describing the entry selection criteria, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example shows how extract all X\+ML files modified after 15 January 2009, overwriting any existing files. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipArchiveName))
\{
  zip.ExtractSelectedEntries(\textcolor{stringliteral}{"name = *.xml  and  mtime > 2009-01-15"},
                             \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.OverwriteSilently);
\}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the selection criteria for entries to extract.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em extract\+Existing\+File} & The action to take if extraction would overwrite an existing file. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1ac2b7437a1466144e783df63ff15fb4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1ac2b7437a1466144e783df63ff15fb4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Selected\+Entries@{Extract\+Selected\+Entries}}
\index{Extract\+Selected\+Entries@{Extract\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Selected\+Entries()}{ExtractSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [3/5]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The entries are selected from the specified directory within the archive, and then extracted into the current working directory. 

If any of the files to be extracted already exist, then the action taken is as specified in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_ad1ab903c29b91edb82e7c6a9768552dd}{Zip\+Entry.\+Extract\+Existing\+File}} property on the corresponding \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instance. By default, the action taken in this case is to throw an exception. 

For information on the syntax of the string describing the entry selection criteria, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example shows how extract all X\+ML files modified after 15 January 2009, and writes them to the \char`\"{}unpack\char`\"{} directory. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipArchiveName))
\{
  zip.ExtractSelectedEntries(\textcolor{stringliteral}{"name = *.xml  and  mtime > 2009-01-15"},\textcolor{stringliteral}{"unpack"});
\}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the selection criteria for entries to extract.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & the directory in the archive from which to select entries. If null, then all directories in the archive are used. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
Extract\+Selected\+Entries(\+String,\+String,\+String,\+Extract\+Existing\+File\+Action)


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a823e5ba928d8990df77058f50b41ebc9}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a823e5ba928d8990df77058f50b41ebc9}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Selected\+Entries@{Extract\+Selected\+Entries}}
\index{Extract\+Selected\+Entries@{Extract\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Selected\+Entries()}{ExtractSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [4/5]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{string}]{directory\+In\+Archive,  }\item[{string}]{extract\+Directory }\end{DoxyParamCaption})}



Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The entries are extracted into the specified directory. If any of the files to be extracted already exist, an exception will be thrown. 

For information on the syntax of the string describing the entry selection criteria, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the selection criteria for entries to extract.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+In\+Archive} & the directory in the archive from which to select entries. If null, then all directories in the archive are used. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em extract\+Directory} & the directory on the disk into which to extract. It will be created if it does not exist. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a577a98ca3edfabaeacd418383fb1655c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a577a98ca3edfabaeacd418383fb1655c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Selected\+Entries@{Extract\+Selected\+Entries}}
\index{Extract\+Selected\+Entries@{Extract\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Selected\+Entries()}{ExtractSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [5/5]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{string}]{directory\+Path\+In\+Archive,  }\item[{string}]{extract\+Directory,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}}}]{extract\+Existing\+File }\end{DoxyParamCaption})}



Selects and Extracts a set of Entries from the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The entries are extracted into the specified directory. When extraction would would overwrite an existing filesystem file, the action taken is as specified in the {\itshape extract\+Existing\+File}  parameter. 

For information on the syntax of the string describing the entry selection criteria, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This example shows how extract all files with an X\+ML extension or with a size larger than 100,000 bytes, and puts them in the unpack directory. For any files that already exist in that destination directory, they will not be overwritten. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipArchiveName))
\{
  zip.ExtractSelectedEntries(\textcolor{stringliteral}{"name = *.xml  or  size > 100000"},
                             null,
                             \textcolor{stringliteral}{"unpack"},
                             \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{ExtractExistingFileAction}}.DontOverwrite);
\}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the selection criteria for entries to extract.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em extract\+Directory} & The directory on the disk into which to extract. It will be created if it does not exist. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & The directory in the archive from which to select entries. If null, then all directories in the archive are used. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em extract\+Existing\+File} & The action to take if extraction would overwrite an existing file. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca101c62532b74ff851ba8f18e0c9091}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aca101c62532b74ff851ba8f18e0c9091}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Fix\+Zip\+Directory@{Fix\+Zip\+Directory}}
\index{Fix\+Zip\+Directory@{Fix\+Zip\+Directory}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Fix\+Zip\+Directory()}{FixZipDirectory()}}
{\footnotesize\ttfamily static void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Fix\+Zip\+Directory (\begin{DoxyParamCaption}\item[{string}]{zip\+File\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Rewrite the directory within a zipfile. 

In cases of data error, the directory in a zip file can get out of synch with the entries in the zip file. This method attempts to fix the zip file if this has occurred. 

This can take a long time for large zip files. 

This won\textquotesingle{}t work if the zip file uses a non-\/standard code page -\/ neither I\+B\+M437 nor U\+T\+F-\/8. 

This method is not supported in the Reduced or Compact Framework versions of Dot\+Net\+Zip. 

Developers using C\+OM can use the \mbox{\hyperlink{}{Com\+Helper.\+Fix\+Zip\+Directory(\+String)}} method. 


\begin{DoxyParams}{Parameters}
{\em zip\+File\+Name} & The filename to of the zip file to fix.\\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a25223986c875661870fa62d08d68ef45}{Check\+Zip(string)}}, Check\+Zip(string,bool,\+System.\+I\+O.\+Text\+Writer)


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad3c41dee19a5bb1f2779ec232d3c3d0f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad3c41dee19a5bb1f2779ec232d3c3d0f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Get\+Enumerator@{Get\+Enumerator}}
\index{Get\+Enumerator@{Get\+Enumerator}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Get\+Enumerator()}{GetEnumerator()}}
{\footnotesize\ttfamily System.\+Collections.\+Generic.\+I\+Enumerator$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Get\+Enumerator (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Generic I\+Enumerator support, for use of a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} in an enumeration. 

You probably do not want to call {\ttfamily Get\+Enumerator} explicitly. Instead it is implicitly called when you use a \mbox{\hyperlink{}{loop in C\#, or a {\ttfamily For Each} loop in V\+B.\+N\+ET. }}

This example reads a zipfile of a given name, then enumerates the entries in that zip file, and displays the information about each entry on the Console. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipfile))
\{
  \textcolor{keywordtype}{bool} header = \textcolor{keyword}{true};
  \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} zip)
  \{
    \textcolor{keywordflow}{if} (header)
    \{
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"Zipfile: \{0\}"}, zip.Name);
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"Version Needed: 0x\{0:X2\}"}, e.VersionNeeded);
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"BitField: 0x\{0:X2\}"}, e.BitField);
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"Compression Method: 0x\{0:X2\}"}, e.CompressionMethod);
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"\(\backslash\)n\{1,-22\} \{2,-6\} \{3,4\}   \{4,-8\}  \{0\}"},
                    \textcolor{stringliteral}{"Filename"}, \textcolor{stringliteral}{"Modified"}, \textcolor{stringliteral}{"Size"}, \textcolor{stringliteral}{"Ratio"}, \textcolor{stringliteral}{"Packed"});
       \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.String(\textcolor{charliteral}{'-'}, 72));
       header = \textcolor{keyword}{false};
    \}

    \mbox{\hyperlink{namespace_system}{System}}.Console.WriteLine(\textcolor{stringliteral}{"\{1,-22\} \{2,-6\} \{3,4:F0\}%   \{4,-8\}  \{0\}"},
                e.FileName,
                e.LastModified.ToString(\textcolor{stringliteral}{"yyyy-MM-dd HH:mm:ss"}),
                e.UncompressedSize,
                e.CompressionRatio,
                e.CompressedSize);

    e.Extract();
  \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim ZipFileToExtract As String = \textcolor{stringliteral}{"c:\(\backslash\)foo.zip"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToExtract)
    Dim header As Boolean = True
    Dim e As ZipEntry
    For Each e In zip
        If header Then
            Console.WriteLine(\textcolor{stringliteral}{"Zipfile: \{0\}"}, zip.Name)
            Console.WriteLine(\textcolor{stringliteral}{"Version Needed: 0x\{0:X2\}"}, e.VersionNeeded)
            Console.WriteLine(\textcolor{stringliteral}{"BitField: 0x\{0:X2\}"}, e.BitField)
            Console.WriteLine(\textcolor{stringliteral}{"Compression Method: 0x\{0:X2\}"}, e.CompressionMethod)
            Console.WriteLine(ChrW(10) &amp; \textcolor{stringliteral}{"\{1,-22\} \{2,-6\} \{3,4\}   \{4,-8\}  \{0\}"}, \_
              \textcolor{stringliteral}{"Filename"}, \textcolor{stringliteral}{"Modified"}, \textcolor{stringliteral}{"Size"}, \textcolor{stringliteral}{"Ratio"}, \textcolor{stringliteral}{"Packed"} )
            Console.WriteLine(New String(\textcolor{stringliteral}{"-"}c, 72))
            header = False
        End If
        Console.WriteLine(\textcolor{stringliteral}{"\{1,-22\} \{2,-6\} \{3,4:F0\}%   \{4,-8\}  \{0\}"}, \_
          e.FileName, \_
          e.LastModified.ToString(\textcolor{stringliteral}{"yyyy-MM-dd HH:mm:ss"}), \_
          e.UncompressedSize, \_
          e.CompressionRatio, \_
          e.CompressedSize )
        e.Extract
    Next
End Using
\end{DoxyCode}
 

\begin{DoxyReturn}{Returns}
A generic enumerator suitable for use within a foreach loop.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a884c0d3669a3f3e80ec6280dfbfa3882}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a884c0d3669a3f3e80ec6280dfbfa3882}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Get\+New\+Enum@{Get\+New\+Enum}}
\index{Get\+New\+Enum@{Get\+New\+Enum}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Get\+New\+Enum()}{GetNewEnum()}}
{\footnotesize\ttfamily System.\+Collections.\+I\+Enumerator Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Get\+New\+Enum (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



An I\+Enumerator, for use of a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} in a foreach construct. 

This method is included for C\+OM support. An application generally does not call this method directly. It is called implicitly by C\+OM clients when enumerating the entries in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance. In V\+B\+Script, this is done with a {\ttfamily For Each} statement. In Javascript, this is done with {\ttfamily new Enumerator(zipfile)}. 

\begin{DoxyReturn}{Returns}
The I\+Enumerator over the entries in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2b07c611d58c3a2c0b59ec14eea02179}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2b07c611d58c3a2c0b59ec14eea02179}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Initialize@{Initialize}}
\index{Initialize@{Initialize}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Initialize()}{Initialize()}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Initialize (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})}



Initialize a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance by reading in a zip file. 

This method is primarily useful from C\+OM Automation environments, when reading or extracting zip files. In C\+OM, it is not possible to invoke parameterized constructors for a class. A C\+OM Automation application can update a zip file by using the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{default (no argument) constructor}}, then calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2b07c611d58c3a2c0b59ec14eea02179}{Initialize()}}} to read the contents of an on-\/disk zip archive into the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

.N\+ET applications are encouraged to use the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}} methods for better clarity. 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & the name of the existing zip file to read in.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae768213f1dc3cd7a1d62cf42af359d2b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae768213f1dc3cd7a1d62cf42af359d2b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Is\+Zip\+File@{Is\+Zip\+File}}
\index{Is\+Zip\+File@{Is\+Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Is\+Zip\+File()}{IsZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Is\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks the given file to see if it appears to be a valid zip file. 

Calling this method is equivalent to calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abc936816e59ebc2a66ace620b6bc2632}{Is\+Zip\+File(string,
  bool)}} with the test\+Extract parameter set to false. 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & The file to check.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the file appears to be a zip file.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abc936816e59ebc2a66ace620b6bc2632}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abc936816e59ebc2a66ace620b6bc2632}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Is\+Zip\+File@{Is\+Zip\+File}}
\index{Is\+Zip\+File@{Is\+Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Is\+Zip\+File()}{IsZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Is\+Zip\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{bool}]{test\+Extract }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks a file to see if it is a valid zip file. 

This method opens the specified zip file, reads in the zip archive, verifying the Z\+IP metadata as it reads. 

If everything succeeds, then the method returns true. If anything fails -\/ for example if an incorrect signature or C\+RC is found, indicating a corrupt file, the the method returns false. This method also returns false for a file that does not exist. 

If {\itshape test\+Extract}  is true, as part of its check, this method reads in the content for each entry, expands it, and checks C\+R\+Cs. This provides an additional check beyond verifying the zip header and directory data. 

If {\itshape test\+Extract}  is true, and if any of the zip entries are protected with a password, this method will return false. If you want to verify a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} that has entries which are protected with a password, you will need to do that manually. 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & The zip file to check.\\
\hline
{\em test\+Extract} & true if the caller wants to extract each entry.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the file contains a valid zip file.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5a708fa7eafd96bfc010b5419b878544}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5a708fa7eafd96bfc010b5419b878544}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Is\+Zip\+File@{Is\+Zip\+File}}
\index{Is\+Zip\+File@{Is\+Zip\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Is\+Zip\+File()}{IsZipFile()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily static bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Is\+Zip\+File (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{stream,  }\item[{bool}]{test\+Extract }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Checks a stream to see if it contains a valid zip archive. 

This method reads the zip archive contained in the specified stream, verifying the Z\+IP metadata as it reads. If test\+Extract is true, this method also extracts each entry in the archive, dumping all the bits into Stream.\+Null. 

If everything succeeds, then the method returns true. If anything fails -\/ for example if an incorrect signature or C\+RC is found, indicating a corrupt file, the the method returns false. This method also returns false for a file that does not exist. 

If {\ttfamily test\+Extract} is true, this method reads in the content for each entry, expands it, and checks C\+R\+Cs. This provides an additional check beyond verifying the zip header data. 

If {\ttfamily test\+Extract} is true, and if any of the zip entries are protected with a password, this method will return false. If you want to verify a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has entries which are protected with a password, you will need to do that manually. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abc936816e59ebc2a66ace620b6bc2632}{Is\+Zip\+File(string, bool)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em stream} & The stream to check.\\
\hline
{\em test\+Extract} & true if the caller wants to extract each entry.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the stream contains a valid zip archive.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Read@{Read}}
\index{Read@{Read}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [1/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Read (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reads a zip file archive and returns the instance. 

The stream is read using the default {\ttfamily System.\+Text.\+Encoding}, which is the {\ttfamily I\+B\+M437} codepage. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} cannot be read. The implementation of this method relies on {\ttfamily System.\+I\+O.\+File.\+Open\+Read}, which can throw a variety of exceptions, including specific exceptions if a file is not found, an unauthorized access exception, exceptions for poorly formatted filenames, and so on. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the zip archive to open. This can be a fully-\/qualified or relative pathname. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
Zip\+File.\+Read(\+String, Read\+Options)


\end{DoxySeeAlso}
.

\begin{DoxyReturn}{Returns}
The instance read from the zip archive.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af8aab0e7643c202a2171731288230d59}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af8aab0e7643c202a2171731288230d59}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Read@{Read}}
\index{Read@{Read}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [2/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Read (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_options}{Read\+Options}}}]{options }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reads a zip file archive from the named filesystem file using the specified options. 

This version of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Read()}}} method allows the caller to pass in a {\ttfamily Text\+Writer} an {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}}}, via an instance of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_options}{Read\+Options}}} class. The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} is read in using the specified encoding for entries where U\+T\+F-\/8 encoding is not explicitly specified. 

This example shows how to read a zip file using the Big-\/5 Chinese code page (950), and extract each entry in the zip file, while sending status messages out to the Console. 

For this code to work as intended, the zipfile must have been created using the big5 code page (C\+P950). This is typical, for example, when using Win\+Rar on a machine with C\+P950 set as the default code page. In that case, the names of entries within the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive will be stored in that code page, and reading the zip archive must be done using that code page. If the application did not use the correct code page in \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}, then names of entries within the zip archive would not be correctly retrieved. 


\begin{DoxyCode}
\textcolor{keywordtype}{string} zipToExtract = \textcolor{stringliteral}{"MyArchive.zip"};
\textcolor{keywordtype}{string} extractDirectory = \textcolor{stringliteral}{"extract"};
var options = \textcolor{keyword}{new} ReadOptions
\{
  StatusMessageWriter = \mbox{\hyperlink{namespace_system}{System}}.Console.Out,
  Encoding = \mbox{\hyperlink{namespace_system}{System}}.Text.Encoding.GetEncoding(950)
\};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipToExtract, options))
\{
  \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} zip)
  \{
     e.Extract(extractDirectory);
  \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim zipToExtract as String = \textcolor{stringliteral}{"MyArchive.zip"}
Dim extractDirectory as String = \textcolor{stringliteral}{"extract"}
Dim options as New ReadOptions
options.Encoding = \mbox{\hyperlink{namespace_system}{System}}.Text.Encoding.GetEncoding(950)
options.StatusMessageWriter = \mbox{\hyperlink{namespace_system}{System}}.Console.Out
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipToExtract, options)
    Dim e As ZipEntry
    For Each e In zip
     e.Extract(extractDirectory)
    Next
End Using
\end{DoxyCode}
 

This example shows how to read a zip file using the default code page, to remove entries that have a modified date before a given threshold, sending status messages out to a {\ttfamily String\+Writer}. 


\begin{DoxyCode}
var options = \textcolor{keyword}{new} ReadOptions
\{
  StatusMessageWriter = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.IO.StringWriter()
\};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip =  \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"PackedDocuments.zip"}, options))
\{
  var Threshold = \textcolor{keyword}{new} DateTime(2007,7,4);
  \textcolor{comment}{// We cannot remove the entry from the list, within the context of}
  \textcolor{comment}{// an enumeration of said list.}
  \textcolor{comment}{// So we add the doomed entry to a list to be removed later.}
  \textcolor{comment}{// pass 1: mark the entries for removal}
  var MarkedEntries = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.Collections.Generic.List<ZipEntry>();
  \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} zip)
  \{
    \textcolor{keywordflow}{if} (e.LastModified < Threshold)
      MarkedEntries.Add(e);
  \}
  \textcolor{comment}{// pass 2: actually remove the entry.}
  \textcolor{keywordflow}{foreach} (ZipEntry zombie \textcolor{keywordflow}{in} MarkedEntries)
     zip.RemoveEntry(zombie);
  zip.Comment = \textcolor{stringliteral}{"This archive has been updated."};
  zip.Save();
\}
\textcolor{comment}{// can now use contents of sw, eg store in an audit log}
\end{DoxyCode}



\begin{DoxyCode}
Dim options as New ReadOptions
options.StatusMessageWriter = New \mbox{\hyperlink{namespace_system}{System}}.IO.StringWriter
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"PackedDocuments.zip"}, options)
    Dim Threshold As New DateTime(2007, 7, 4)
    \textcolor{stringliteral}{' We cannot remove the entry from the list, within the context of}
\textcolor{stringliteral}{    '} an enumeration of said list.
    \textcolor{stringliteral}{' So we add the doomed entry to a list to be removed later.}
\textcolor{stringliteral}{    '} pass 1: mark the entries \textcolor{keywordflow}{for} removal
    Dim MarkedEntries As New \mbox{\hyperlink{namespace_system}{System}}.Collections.Generic.List(Of ZipEntry)
    Dim e As ZipEntry
    For Each e In zip
        If (e.LastModified < Threshold) Then
            MarkedEntries.Add(e)
        End If
    Next
    \textcolor{stringliteral}{' pass 2: actually remove the entry.}
\textcolor{stringliteral}{    Dim zombie As ZipEntry}
\textcolor{stringliteral}{    For Each zombie In MarkedEntries}
\textcolor{stringliteral}{        zip.RemoveEntry(zombie)}
\textcolor{stringliteral}{    Next}
\textcolor{stringliteral}{    zip.Comment = "This archive has been updated."}
\textcolor{stringliteral}{    zip.Save}
\textcolor{stringliteral}{End Using}
\textcolor{stringliteral}{'} can now use contents of sw, eg store in an audit log
\end{DoxyCode}
 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if the zipfile cannot be read. The implementation of this method relies on {\ttfamily System.\+I\+O.\+File.\+Open\+Read}, which can throw a variety of exceptions, including specific exceptions if a file is not found, an unauthorized access exception, exceptions for poorly formatted filenames, and so on. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the zip archive to open. This can be a fully-\/qualified or relative pathname. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em options} & The set of options to use when reading the zip file. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance read from the zip archive.
\end{DoxyReturn}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a158599d431cb5649f7729fd6f9a1e0af}{Zip\+File.\+Read(\+Stream, Read\+Options)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a51271b0f357c968e6f34be8f1daec490}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a51271b0f357c968e6f34be8f1daec490}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Read@{Read}}
\index{Read@{Read}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [3/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{zip\+Stream }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reads a zip archive from a stream. 

When reading from a file, it\textquotesingle{}s probably easier to just use \mbox{\hyperlink{}{Zip\+File.\+Read(\+String, Read\+Options)}}. This overload is useful when when the zip archive content is available from an already-\/open stream. The stream must be open and readable and seekable when calling this method. The stream is left open when the reading is completed. 

Using this overload, the stream is read using the default {\ttfamily System.\+Text.\+Encoding}, which is the {\ttfamily I\+B\+M437} codepage. If you want to specify the encoding to use when reading the zipfile content, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a158599d431cb5649f7729fd6f9a1e0af}{Zip\+File.\+Read(\+Stream, Read\+Options)}}. This 

Reading of zip content begins at the current position in the stream. This means if you have a stream that concatenates regular data and zip data, if you position the open, readable stream at the start of the zip data, you will be able to read the zip archive using this constructor, or any of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} constructors that accept a System.\+I\+O.\+Stream as input. Some examples of where this might be useful\+: the zip content is concatenated at the end of a regular E\+XE file, as some self-\/extracting archives do. (Note\+: S\+FX files produced by Dot\+Net\+Zip do not work this way; they can be read as normal Z\+IP files). Another example might be a stream being read from a database, where the zip content is embedded within an aggregate stream of data. 

This example shows how to Read zip content from a stream, and extract one entry into a different stream. In this example, the filename \char`\"{}\+Name\+Of\+Entry\+In\+Archive.\+doc\char`\"{}, refers only to the name of the entry within the zip archive. A file by that name is not created in the filesystem. The I/O is done strictly with the given streams. 


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(InputStream))
\{
   zip.Extract(\textcolor{stringliteral}{"NameOfEntryInArchive.doc"}, OutputStream);
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip as \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(InputStream)
   zip.Extract(\textcolor{stringliteral}{"NameOfEntryInArchive.doc"}, OutputStream)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em zip\+Stream} & the stream containing the zip data.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance read from the stream
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a158599d431cb5649f7729fd6f9a1e0af}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a158599d431cb5649f7729fd6f9a1e0af}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Read@{Read}}
\index{Read@{Read}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Read()}{Read()}\hspace{0.1cm}{\footnotesize\ttfamily [4/4]}}
{\footnotesize\ttfamily static \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Read (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{zip\+Stream,  }\item[{\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_options}{Read\+Options}}}]{options }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [static]}}



Reads a zip file archive from the given stream using the specified options. 

When reading from a file, it\textquotesingle{}s probably easier to just use \mbox{\hyperlink{}{Zip\+File.\+Read(\+String, Read\+Options)}}. This overload is useful when when the zip archive content is available from an already-\/open stream. The stream must be open and readable and seekable when calling this method. The stream is left open when the reading is completed. 

Reading of zip content begins at the current position in the stream. This means if you have a stream that concatenates regular data and zip data, if you position the open, readable stream at the start of the zip data, you will be able to read the zip archive using this constructor, or any of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} constructors that accept a System.\+I\+O.\+Stream as input. Some examples of where this might be useful\+: the zip content is concatenated at the end of a regular E\+XE file, as some self-\/extracting archives do. (Note\+: S\+FX files produced by Dot\+Net\+Zip do not work this way; they can be read as normal Z\+IP files). Another example might be a stream being read from a database, where the zip content is embedded within an aggregate stream of data. 


\begin{DoxyParams}{Parameters}
{\em zip\+Stream} & the stream containing the zip data.\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em options} & The set of options to use when reading the zip file. \\
\hline
\end{DoxyParams}



\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if the zip archive cannot be read. \\
\hline
\end{DoxyExceptions}


\begin{DoxyReturn}{Returns}
The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance read from the stream.
\end{DoxyReturn}


\begin{DoxySeeAlso}{See also}
Zip\+File.\+Read(\+String, Read\+Options)


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9347964fdaa19da7fd253f53b0f550c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9347964fdaa19da7fd253f53b0f550c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Entries@{Remove\+Entries}}
\index{Remove\+Entries@{Remove\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Entries()}{RemoveEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Entries (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Collection$<$ \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} $>$}]{entries\+To\+Remove }\end{DoxyParamCaption})}



This method removes a collection of entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 


\begin{DoxyParams}{Parameters}
{\em entries\+To\+Remove} & A collection of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instances from this zip file to be removed. For example, you can pass in an array of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} instances; or you can call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}{Select\+Entries()}}, and then add or remove entries from that I\+Collection$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ (I\+Collection(\+Of Zip\+Entry) in VB), and pass that I\+Collection to this method. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}{Ionic.\+Zip.\+Zip\+File.\+Select\+Entries(\+String)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa65fbbd260db3979088aacf9a033663f}{Ionic.\+Zip.\+Zip\+File.\+Remove\+Selected\+Entries(\+String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a110e34e551b1282f9eaf1dfac5d58dac}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a110e34e551b1282f9eaf1dfac5d58dac}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Entries@{Remove\+Entries}}
\index{Remove\+Entries@{Remove\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Entries()}{RemoveEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Entries (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Collection$<$ String $>$}]{entries\+To\+Remove }\end{DoxyParamCaption})}



This method removes a collection of entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, by name. 


\begin{DoxyParams}{Parameters}
{\em entries\+To\+Remove} & A collection of strings that refer to names of entries to be removed from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. For example, you can pass in an array or a List of Strings that provide the names of entries to be removed. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}{Ionic.\+Zip.\+Zip\+File.\+Select\+Entries(\+String)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa65fbbd260db3979088aacf9a033663f}{Ionic.\+Zip.\+Zip\+File.\+Remove\+Selected\+Entries(\+String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Entry@{Remove\+Entry}}
\index{Remove\+Entry@{Remove\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Entry()}{RemoveEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Entry (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}]{entry }\end{DoxyParamCaption})}



Removes the given {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} from the zip archive. 

After calling {\ttfamily Remove\+Entry}, the application must call {\ttfamily Save} to make the changes permanent. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Thrown if the specified {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} does not exist in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \\
\hline
\end{DoxyExceptions}


In this example, all entries in the zip archive dating from before December 31st, 2007, are removed from the archive. This is actually much easier if you use the Remove\+Selected\+Entries method. But I needed an example for Remove\+Entry, so here it is. 
\begin{DoxyCode}
String ZipFileToRead = \textcolor{stringliteral}{"ArchiveToModify.zip"};
\mbox{\hyperlink{namespace_system}{System}}.DateTime Threshold = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.DateTime(2007,12,31);
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToRead))
\{
  var EntriesToRemove = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.Collections.Generic.List<ZipEntry>();
  \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} zip)
  \{
    \textcolor{keywordflow}{if} (e.LastModified < Threshold)
    \{
      \textcolor{comment}{// We cannot remove the entry from the list, within the context of}
      \textcolor{comment}{// an enumeration of said list.}
      \textcolor{comment}{// So we add the doomed entry to a list to be removed later.}
      EntriesToRemove.Add(e);
    \}
  \}

  \textcolor{comment}{// actually remove the doomed entries.}
  \textcolor{keywordflow}{foreach} (ZipEntry zombie \textcolor{keywordflow}{in} EntriesToRemove)
    zip.RemoveEntry(zombie);

  zip.Comment= String.Format(\textcolor{stringliteral}{"This zip archive was updated at \{0\}."},
                             \mbox{\hyperlink{namespace_system}{System}}.DateTime.Now.ToString(\textcolor{stringliteral}{"G"}));

  \textcolor{comment}{// save with a different name}
  zip.Save(\textcolor{stringliteral}{"Archive-Updated.zip"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Dim ZipFileToRead As String = \textcolor{stringliteral}{"ArchiveToModify.zip"}
Dim Threshold As New DateTime(2007, 12, 31)
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Read}}(ZipFileToRead)
    Dim EntriesToRemove As New \mbox{\hyperlink{namespace_system}{System}}.Collections.Generic.List(Of ZipEntry)
    Dim e As ZipEntry
    For Each e In zip
        If (e.LastModified < Threshold) Then
            ' We cannot remove the entry from the list, within the context of
            ' an enumeration of said list.
            ' So we add the doomed entry to a list to be removed later.
            EntriesToRemove.Add(e)
        End If
    Next

    ' actually remove the doomed entries.
    Dim zombie As ZipEntry
    For Each zombie In EntriesToRemove
        zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}{RemoveEntry}}(zombie)
    Next
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}} = String.Format("This zip archive was updated at \{0\}.\textcolor{stringliteral}{", DateTime.Now.ToString("}G\textcolor{stringliteral}{"))}
\textcolor{stringliteral}{    'save as a different name}
\textcolor{stringliteral}{    zip.Save("}Archive-Updated.zip\textcolor{stringliteral}{")}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em entry} & The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} to remove from the zip. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Remove\+Selected\+Entries(string)


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a79cc2680a4476d0873bf16aec3a87360}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a79cc2680a4476d0873bf16aec3a87360}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Entry@{Remove\+Entry}}
\index{Remove\+Entry@{Remove\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Entry()}{RemoveEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Entry (\begin{DoxyParamCaption}\item[{String}]{file\+Name }\end{DoxyParamCaption})}



Removes the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} with the given filename from the zip archive. 

After calling {\ttfamily Remove\+Entry}, the application must call {\ttfamily Save} to make the changes permanent. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Invalid\+Operation\+Exception} & Thrown if the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} is not updatable. \\
\hline
\end{DoxyExceptions}



\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Thrown if a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} with the specified filename does not exist in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \\
\hline
\end{DoxyExceptions}


This example shows one way to remove an entry with a given filename from an existing zip archive.


\begin{DoxyCode}
String zipFileToRead= \textcolor{stringliteral}{"PackedDocuments.zip"};
\textcolor{keywordtype}{string} candidate = \textcolor{stringliteral}{"DatedMaterial.xps"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipFileToRead))
\{
  \textcolor{keywordflow}{if} (zip.EntryFilenames.Contains(candidate))
  \{
    zip.RemoveEntry(candidate);
    zip.Comment= String.Format(\textcolor{stringliteral}{"The file '\{0\}' has been removed from this archive."},
                               Candidate);
    zip.Save();
  \}
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Dim zipFileToRead As String = \textcolor{stringliteral}{"PackedDocuments.zip"}
Dim candidate As String = \textcolor{stringliteral}{"DatedMaterial.xps"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipFileToRead)
    If zip.EntryFilenames.Contains(candidate) Then
        zip.RemoveEntry(candidate)
        zip.Comment = String.Format(\textcolor{stringliteral}{"The file '\{0\}' has been removed from this archive."}, Candidate)
        zip.Save
    End If
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file, including any directory path, to remove from the zip. The filename match is not case-\/sensitive by default; you can use the {\ttfamily Case\+Sensitive\+Retrieval} property to change this behavior. The pathname can use forward-\/slashes or backward slashes. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa65fbbd260db3979088aacf9a033663f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa65fbbd260db3979088aacf9a033663f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Selected\+Entries@{Remove\+Selected\+Entries}}
\index{Remove\+Selected\+Entries@{Remove\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Selected\+Entries()}{RemoveSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria }\end{DoxyParamCaption})}



Remove entries from the zipfile by specified criteria. 

This method allows callers to remove the collection of entries from the zipfile that fit the specified criteria. The criteria are described in a string format, and can include patterns for the filename; constraints on the size of the entry; constraints on the last modified, created, or last accessed time for the file described by the entry; or the attributes of the entry. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This method is intended for use with a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has been read from storage. When creating a new \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, this method will work only after the Zip\+Archive has been Saved to the disk (the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} class subsequently and implicitly reads the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive from storage.) Calling Select\+Entries on a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has not yet been saved will deliver undefined results. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if selection\+Criteria has an invalid syntax. \\
\hline
\end{DoxyExceptions}


This example removes all entries in a zip file that were modified prior to January 1st, 2008. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName))
\{
    \textcolor{comment}{// remove all entries from prior to Jan 1, 2008}
    zip1.RemoveEntries(\textcolor{stringliteral}{"mtime < 2008-01-01"});
    \textcolor{comment}{// don't forget to save the archive!}
    zip1.Save();
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName)
    \textcolor{stringliteral}{' remove all entries from prior to Jan 1, 2008}
\textcolor{stringliteral}{    zip1.RemoveEntries("mtime < 2008-01-01")}
\textcolor{stringliteral}{    '} \textcolor{keywordflow}{do} not forget to save the archive!
    zip1.Save
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the string that specifies which entries to select\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of entries removed
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbe575a1613b0f5da35f0979e3492d9}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbe575a1613b0f5da35f0979e3492d9}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Remove\+Selected\+Entries@{Remove\+Selected\+Entries}}
\index{Remove\+Selected\+Entries@{Remove\+Selected\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Remove\+Selected\+Entries()}{RemoveSelectedEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Remove\+Selected\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{string}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Remove entries from the zipfile by specified criteria, and within the specified path in the archive. 

This method allows callers to remove the collection of entries from the zipfile that fit the specified criteria. The criteria are described in a string format, and can include patterns for the filename; constraints on the size of the entry; constraints on the last modified, created, or last accessed time for the file described by the entry; or the attributes of the entry. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This method is intended for use with a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has been read from storage. When creating a new \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, this method will work only after the Zip\+Archive has been Saved to the disk (the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} class subsequently and implicitly reads the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive from storage.) Calling Select\+Entries on a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has not yet been saved will deliver undefined results. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if selection\+Criteria has an invalid syntax. \\
\hline
\end{DoxyExceptions}



\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName))
\{
    \textcolor{comment}{// remove all entries from prior to Jan 1, 2008}
    zip1.RemoveEntries(\textcolor{stringliteral}{"mtime < 2008-01-01"}, \textcolor{stringliteral}{"documents"});
    \textcolor{comment}{// a call to ZipFile.Save will make the modifications permanent}
    zip1.Save();
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName)
    \textcolor{stringliteral}{' remove all entries from prior to Jan 1, 2008}
\textcolor{stringliteral}{    zip1.RemoveEntries("mtime < 2008-01-01", "documents")}
\textcolor{stringliteral}{    '} a call to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Save will make the modifications permanent
    zip1.Save
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the string that specifies which entries to select\\
\hline
{\em directory\+Path\+In\+Archive} & the directory in the archive from which to select entries. If null, then all directories in the archive are used. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
the number of entries removed
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save@{Save}}
\index{Save@{Save}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save()}{Save()}\hspace{0.1cm}{\footnotesize\ttfamily [1/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Saves the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive to a file, specified by the Name property of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance is written to storage, typically a zip file in a filesystem, only when the caller calls {\ttfamily Save}. In the typical case, the Save operation writes the zip content to a temporary file, and then renames the temporary file to the desired name. If necessary, this method will delete a pre-\/existing file before the rename. 

The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}{Zip\+File.\+Name}} property is specified either explicitly, or implicitly using one of the parameterized \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} constructors. For C\+OM Automation clients, the {\ttfamily Name} property must be set explicitly, because C\+OM Automation clients cannot call parameterized constructors. 

When using a filesystem file for the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} output, it is possible to call {\ttfamily Save} multiple times on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. With each call the zip content is re-\/written to the same output file. 

Data for entries that have been added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance is written to the output when the {\ttfamily Save} method is called. This means that the input streams for those entries must be available at the time the application calls {\ttfamily Save}. If, for example, the application adds entries with {\ttfamily Add\+Entry} using a dynamically-\/allocated {\ttfamily Memory\+Stream}, the memory stream must not have been disposed before the call to {\ttfamily Save}. See the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9c5db72a0ee3dad46be934c75ffcfe91}{Zip\+Entry.\+Input\+Stream}} property for more discussion of the availability requirements of the input stream for an entry, and an approach for providing just-\/in-\/time stream lifecycle management. 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+Entry(\+String, System.\+I\+O.\+Stream)


\end{DoxySeeAlso}



\begin{DoxyExceptions}{Exceptions}
{\em \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_bad_state_exception}{Ionic.\+Zip.\+Bad\+State\+Exception}}} & Thrown if you haven\textquotesingle{}t specified a location or stream for saving the zip, either in the constructor or by setting the Name property, or if you try to save a regular zip archive to a filename with a .exe extension. \\
\hline
\end{DoxyExceptions}



\begin{DoxyExceptions}{Exceptions}
{\em System.\+Overflow\+Exception} & Thrown if \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}{Max\+Output\+Segment\+Size}} is non-\/zero, and the number of segments that would be generated for the spanned zip file during the save operation exceeds 99. If this happens, you need to increase the segment size. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save@{Save}}
\index{Save@{Save}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save()}{Save()}\hspace{0.1cm}{\footnotesize\ttfamily [2/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save (\begin{DoxyParamCaption}\item[{String}]{file\+Name }\end{DoxyParamCaption})}



Save the file to a new zipfile, with the given name. 

This method allows the application to explicitly specify the name of the zip file when saving. Use this when creating a new zip file, or when updating a zip archive. 

An application can also save a zip archive in several places by calling this method multiple times in succession, with different filenames. 

The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance is written to storage, typically a zip file in a filesystem, only when the caller calls {\ttfamily Save}. The Save operation writes the zip content to a temporary file, and then renames the temporary file to the desired name. If necessary, this method will delete a pre-\/existing file before the rename. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Thrown if you specify a directory for the filename. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the zip archive to save to. Existing files will be overwritten with great prejudice. \\
\hline
\end{DoxyParams}


This example shows how to create and Save a zip file. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  zip.AddDirectory(\textcolor{stringliteral}{@"c:\(\backslash\)reports\(\backslash\)January"});
  zip.Save(\textcolor{stringliteral}{"January.zip"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
  zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{AddDirectory}}("c:\(\backslash\)reports\(\backslash\)January")
  zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}("January.zip")
End Using
\end{DoxyCode}


This example shows how to update a zip file. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"ExistingArchive.zip"}))
\{
  zip.AddFile(\textcolor{stringliteral}{"NewData.csv"});
  zip.Save(\textcolor{stringliteral}{"UpdatedArchive.zip"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"ExistingArchive.zip"})
  zip.AddFile(\textcolor{stringliteral}{"NewData.csv"})
  zip.Save(\textcolor{stringliteral}{"UpdatedArchive.zip"})
End Using
\end{DoxyCode}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af6e6cb1b5da4c7e97bde2dfe1cac3fd1}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af6e6cb1b5da4c7e97bde2dfe1cac3fd1}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save@{Save}}
\index{Save@{Save}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save()}{Save()}\hspace{0.1cm}{\footnotesize\ttfamily [3/3]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save (\begin{DoxyParamCaption}\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{output\+Stream }\end{DoxyParamCaption})}



Save the zip archive to the specified stream. 

The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance is written to storage -\/ typically a zip file in a filesystem, but using this overload, the storage can be anything accessible via a writable stream -\/ only when the caller calls {\ttfamily Save}. 

Use this method to save the zip content to a stream directly. A common scenario is an A\+S\+P.\+N\+ET application that dynamically generates a zip file and allows the browser to download it. The application can call {\ttfamily Save(Response.\+Output\+Stream)} to write a zipfile directly to the output stream, without creating a zip file on the disk on the A\+S\+P.\+N\+ET server. 

Be careful when saving a file to a non-\/seekable stream, including {\ttfamily Response.\+Output\+Stream}. When Dot\+Net\+Zip writes to a non-\/seekable stream, the zip archive is formatted in such a way that may not be compatible with all zip tools on all platforms. It\textquotesingle{}s a perfectly legal and compliant zip file, but some people have reported problems opening files produced this way using the Mac OS archive utility. 

This example saves the zipfile content into a Memory\+Stream, and then gets the array of bytes from that Memory\+Stream.


\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} Ionic.Zip.ZipFile())
\{
    zip.CompressionLevel= Ionic.Zlib.CompressionLevel.BestCompression;
    zip.Password = \textcolor{stringliteral}{"VerySecret."};
    zip.Encryption = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa3f4e8aa12ef827ac72177a49b4e28e6}{EncryptionAlgorithm}}.WinZipAes128;
    zip.AddFile(sourceFileName);
    MemoryStream output = \textcolor{keyword}{new} MemoryStream();
    zip.Save(output);

    byte[] zipbytes = output.ToArray();
\}
\end{DoxyCode}
 

This example shows a pitfall you should avoid. DO N\+OT read from a stream, then try to save to the same stream. DO N\+OT DO T\+H\+IS\+: 


\begin{DoxyCode}
\textcolor{keyword}{using} (var fs = \textcolor{keyword}{new} FileSteeam(filename, FileMode.Open))
\{
  \textcolor{keyword}{using} (var zip = Ionic.Zip.ZipFile.Read(inputStream))
  \{
    zip.AddEntry(\textcolor{stringliteral}{"Name1.txt"}, \textcolor{stringliteral}{"this is the content"});
    zip.Save(inputStream);  \textcolor{comment}{// NO NO NO!!}
  \}
\}
\end{DoxyCode}


Better like this\+: 


\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = Ionic.Zip.ZipFile.Read(filename))
\{
    zip.AddEntry(\textcolor{stringliteral}{"Name1.txt"}, \textcolor{stringliteral}{"this is the content"});
    zip.Save();  \textcolor{comment}{// YES!}
\}
\end{DoxyCode}



\begin{DoxyParams}{Parameters}
{\em output\+Stream} & The {\ttfamily System.\+I\+O.\+Stream} to write to. It must be writable. If you created the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instanct by calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}, this stream must not be the same stream you passed to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save\+Self\+Extractor@{Save\+Self\+Extractor}}
\index{Save\+Self\+Extractor@{Save\+Self\+Extractor}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save\+Self\+Extractor()}{SaveSelfExtractor()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save\+Self\+Extractor (\begin{DoxyParamCaption}\item[{string}]{exe\+To\+Generate,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{Self\+Extractor\+Flavor}}}]{flavor }\end{DoxyParamCaption})}



Saves the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance to a self-\/extracting zip archive. 

The generated exe image will execute on any machine that has the .N\+ET Framework 2.\+0 installed on it. The generated exe image is also a valid Z\+IP file, readable with Dot\+Net\+Zip or another \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} library or tool such as Win\+Zip. 

There are two \char`\"{}flavors\char`\"{} of self-\/extracting archive. The {\ttfamily Win\+Forms\+Application} version will pop up a G\+UI and allow the user to select a target directory into which to extract. There\textquotesingle{}s also a checkbox allowing the user to specify to overwrite existing files, and another checkbox to allow the user to request that Explorer be opened to see the extracted files after extraction. The other flavor is {\ttfamily Console\+Application}. A self-\/extractor generated with that flavor setting will run from the command line. It accepts command-\/line options to set the overwrite behavior, and to specify the target extraction directory. 

There are a few temporary files created during the saving to a self-\/extracting zip. These files are created in the directory pointed to by \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5b51af53eca5a8c0aa52d950f04c4add}{Zip\+File.\+Temp\+File\+Folder}}, which defaults to System.\+I\+O.\+Path.\+Get\+Temp\+Path. These temporary files are removed upon successful completion of this method. 

When a user runs the Win\+Forms S\+FX, the user\textquotesingle{}s personal directory (\mbox{\hyperlink{}{Environment.\+Special\+Folder.\+Personal}}) will be used as the default extract location. If you want to set the default extract location, you should use the other overload of {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{Save\+Self\+Extractor()}}}/ The user who runs the S\+FX will have the opportunity to change the extract directory before extracting. When the user runs the Command-\/\+Line S\+FX, the user must explicitly specify the directory to which to extract. The .N\+ET Framework 2.\+0 is required on the computer when the self-\/extracting archive is run. 

NB\+: This method is not available in the version of Dot\+Net\+Zip build for the .N\+ET Compact Framework, nor in the \char`\"{}\+Reduced\char`\"{} Dot\+Net\+Zip library. 


\begin{DoxyCode}
\textcolor{keywordtype}{string} DirectoryPath = \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)Documents\(\backslash\)\(\backslash\)Project7"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddDirectory(DirectoryPath, \mbox{\hyperlink{namespace_system}{System}}.IO.Path.GetFileName(DirectoryPath));
    zip.Comment = \textcolor{stringliteral}{"This will be embedded into a self-extracting console-based exe"};
    zip.SaveSelfExtractor(\textcolor{stringliteral}{"archive.exe"}, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.ConsoleApplication);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Dim DirectoryPath As String = \textcolor{stringliteral}{"c:\(\backslash\)Documents\(\backslash\)Project7"}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{AddDirectory}}(DirectoryPath, \mbox{\hyperlink{namespace_system}{System}}.IO.\mbox{\hyperlink{namespace_path}{Path}}.GetFileName(DirectoryPath))
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}} = "This will be embedded into a self-extracting console-based exe"
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{SaveSelfExtractor}}("archive.exe", \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.
      \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963a9e6155c58429c83277586913ab5f0e11}{ConsoleApplication}})
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em exe\+To\+Generate} & a pathname, possibly fully qualified, to be created. Typically it will end in an .exe extension.\\
\hline
{\em flavor} & Indicates whether a Winforms or Console self-\/extractor is desired. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a064e912a1571a38845e5ee1666ca94db}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a064e912a1571a38845e5ee1666ca94db}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save\+Self\+Extractor@{Save\+Self\+Extractor}}
\index{Save\+Self\+Extractor@{Save\+Self\+Extractor}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save\+Self\+Extractor()}{SaveSelfExtractor()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save\+Self\+Extractor (\begin{DoxyParamCaption}\item[{string}]{exe\+To\+Generate,  }\item[{\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_self_extractor_save_options}{Self\+Extractor\+Save\+Options}}}]{options }\end{DoxyParamCaption})}



Saves the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} instance to a self-\/extracting zip archive, using the specified save options. 

This method saves a self extracting archive, using the specified save options. These options include the flavor of the S\+FX, the default extract directory, the icon file, and so on. See the documentation for \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{Save\+Self\+Extractor(string , Self\+Extractor\+Flavor)}} for more details. 

The user who runs the S\+FX will have the opportunity to change the extract directory before extracting. If at the time of extraction, the specified directory does not exist, the S\+FX will create the directory before extracting the files. 

This example saves a Win\+Forms-\/based self-\/extracting archive E\+XE that will use c\+: as the default extract location. The C\# code shows syntax for .N\+ET 3.\+0, which uses an object initializer for the Self\+Extractor\+Options object. 
\begin{DoxyCode}
\textcolor{keywordtype}{string} DirectoryPath = \textcolor{stringliteral}{"c:\(\backslash\)\(\backslash\)Documents\(\backslash\)\(\backslash\)Project7"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddDirectory(DirectoryPath, \mbox{\hyperlink{namespace_system}{System}}.IO.Path.GetFileName(DirectoryPath));
    zip.Comment = \textcolor{stringliteral}{"This will be embedded into a self-extracting WinForms-based exe"};
    var options = \textcolor{keyword}{new} SelfExtractorOptions
    \{
      Flavor = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.WinFormsApplication,
      DefaultExtractDirectory = \textcolor{stringliteral}{"%USERPROFILE%\(\backslash\)\(\backslash\)ExtractHere"},
      PostExtractCommandLine = ExeToRunAfterExtract,
      SfxExeWindowTitle = \textcolor{stringliteral}{"My Custom Window Title"},
      RemoveUnpackedFilesAfterExecute = \textcolor{keyword}{true}
    \};
    zip.SaveSelfExtractor(\textcolor{stringliteral}{"archive.exe"}, options);
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Dim DirectoryPath As String = \textcolor{stringliteral}{"c:\(\backslash\)Documents\(\backslash\)Project7"}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{AddDirectory}}(DirectoryPath, \mbox{\hyperlink{namespace_system}{System}}.IO.\mbox{\hyperlink{namespace_path}{Path}}.GetFileName(DirectoryPath))
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}} = "This will be embedded into a self-extracting console-based exe"
    Dim options As New SelfExtractorOptions()
    options.Flavor = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963a92c4af478ae5363eaacde6de61c1a549}{WinFormsApplication}}
    options.DefaultExtractDirectory = "%USERPROFILE%\(\backslash\)\(\backslash\)ExtractHere"
    options.PostExtractCommandLine = ExeToRunAfterExtract
    options.SfxExeWindowTitle = "My Custom Window Title"
    options.RemoveUnpackedFilesAfterExecute = True
    zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{SaveSelfExtractor}}("archive.exe", options)
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em exe\+To\+Generate} & The name of the E\+XE to generate.\\
\hline
{\em options} & provides the options for creating the Self-\/extracting archive.\\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeede0c5daf05b8600bc0b4e42b20d593}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Select\+Entries@{Select\+Entries}}
\index{Select\+Entries@{Select\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Select\+Entries()}{SelectEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily I\+Collection$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Select\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria }\end{DoxyParamCaption})}



Retrieve entries from the zipfile by specified criteria. 

This method allows callers to retrieve the collection of entries from the zipfile that fit the specified criteria. The criteria are described in a string format, and can include patterns for the filename; constraints on the size of the entry; constraints on the last modified, created, or last accessed time for the file described by the entry; or the attributes of the entry. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This method is intended for use with a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has been read from storage. When creating a new \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, this method will work only after the Zip\+Archive has been Saved to the disk (the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} class subsequently and implicitly reads the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive from storage.) Calling Select\+Entries on a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has not yet been saved will deliver undefined results. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if selection\+Criteria has an invalid syntax. \\
\hline
\end{DoxyExceptions}


This example selects all the Photo\+Shop files from within an archive, and extracts them to the current working directory. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName))
\{
    var PhotoShopFiles = zip1.SelectEntries(\textcolor{stringliteral}{"*.psd"});
    \textcolor{keywordflow}{foreach} (ZipEntry psd \textcolor{keywordflow}{in} PhotoShopFiles)
    \{
        psd.Extract();
    \}
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip1 As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName)
    Dim PhotoShopFiles as ICollection(Of ZipEntry)
    PhotoShopFiles = zip1.SelectEntries(\textcolor{stringliteral}{"*.psd"})
    Dim psd As ZipEntry
    For Each psd In PhotoShopFiles
        psd.Extract
    Next
End Using
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the string that specifies which entries to select\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a collection of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} objects that conform to the inclusion spec
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a76ebbeb552c977eb0622a14d5401f116}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a76ebbeb552c977eb0622a14d5401f116}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Select\+Entries@{Select\+Entries}}
\index{Select\+Entries@{Select\+Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Select\+Entries()}{SelectEntries()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily I\+Collection$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Select\+Entries (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{string}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Retrieve entries from the zipfile by specified criteria. 

This method allows callers to retrieve the collection of entries from the zipfile that fit the specified criteria. The criteria are described in a string format, and can include patterns for the filename; constraints on the size of the entry; constraints on the last modified, created, or last accessed time for the file described by the entry; or the attributes of the entry. 

For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 

This method is intended for use with a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has been read from storage. When creating a new \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, this method will work only after the Zip\+Archive has been Saved to the disk (the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} class subsequently and implicitly reads the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive from storage.) Calling Select\+Entries on a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} that has not yet been saved will deliver undefined results. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+Exception} & Thrown if selection\+Criteria has an invalid syntax. \\
\hline
\end{DoxyExceptions}



\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName))
\{
    var UpdatedPhotoShopFiles = zip1.SelectEntries(\textcolor{stringliteral}{"*.psd"}, \textcolor{stringliteral}{"UpdatedFiles"});
    \textcolor{keywordflow}{foreach} (ZipEntry e \textcolor{keywordflow}{in} UpdatedPhotoShopFiles)
    \{
        \textcolor{comment}{// prompt for extract here}
        \textcolor{keywordflow}{if} (WantExtract(e.FileName))
            e.Extract();
    \}
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip1 As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileName)
    Dim UpdatedPhotoShopFiles As ICollection(Of ZipEntry) = zip1.SelectEntries(\textcolor{stringliteral}{"*.psd"}, \textcolor{stringliteral}{"UpdatedFiles"})
    Dim e As ZipEntry
    For Each e In UpdatedPhotoShopFiles
        \textcolor{stringliteral}{' prompt for extract here}
\textcolor{stringliteral}{        If Me.WantExtract(e.FileName) Then}
\textcolor{stringliteral}{            e.Extract}
\textcolor{stringliteral}{        End If}
\textcolor{stringliteral}{    Next}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & the string that specifies which entries to select\\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & the directory in the archive from which to select entries. If null, then all directories in the archive are used. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
a collection of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} objects that conform to the inclusion spec
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae341d900330121d5dd845d881185537b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae341d900330121d5dd845d881185537b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!To\+String@{To\+String}}
\index{To\+String@{To\+String}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{To\+String()}{ToString()}}
{\footnotesize\ttfamily override String Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+To\+String (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})}



Provides a string representation of the instance.

\begin{DoxyReturn}{Returns}
a string representation of the instance.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Directory@{Update\+Directory}}
\index{Update\+Directory@{Update\+Directory}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Directory()}{UpdateDirectory()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Directory (\begin{DoxyParamCaption}\item[{string}]{directory\+Name }\end{DoxyParamCaption})}



Add or update a directory in a zip archive. 

If the specified directory does not exist in the archive, then this method is equivalent to calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}}}. If the specified directory already exists in the archive, then this method updates any existing entries, and adds any new entries. Any entries that are in the zip archive but not in the specified directory, are left alone. In other words, the contents of the zip file will be a union of the previous contents and the new files. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}{Ionic.\+Zip.\+Zip\+File.\+Update\+File(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em directory\+Name} & The path to the directory to be added to the zip archive, or updated in the zip archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the Directory that was added or updated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa1a7a2fe435a46b6ba009b1f6a24c28f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa1a7a2fe435a46b6ba009b1f6a24c28f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Directory@{Update\+Directory}}
\index{Update\+Directory@{Update\+Directory}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Directory()}{UpdateDirectory()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Directory (\begin{DoxyParamCaption}\item[{string}]{directory\+Name,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Add or update a directory in the zip archive at the specified root directory in the archive. 

If the specified directory does not exist in the archive, then this method is equivalent to calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}}}. If the specified directory already exists in the archive, then this method updates any existing entries, and adds any new entries. Any entries that are in the zip archive but not in the specified directory, are left alone. In other words, the contents of the zip file will be a union of the previous contents and the new files. 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Update\+File(string,string), \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a400574954effbcb8ad0deec2fcab5a54}{Ionic.\+Zip.\+Zip\+File.\+Add\+Directory(string,string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string,string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em directory\+Name} & The path to the directory to be added to the zip archive, or updated in the zip archive. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the {\ttfamily directory\+Name}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on the {\ttfamily directory\+Name}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the Directory that was added or updated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af76606d95dccbe41f72679cae14f06da}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af76606d95dccbe41f72679cae14f06da}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [1/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{string}]{content }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given string as content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. 

Calling this method is equivalent to removing the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} for the given file name and directory path, if it exists, and then calling Add\+Entry(\+String,\+String). See the documentation for that method for further explanation. The string content is encoded using the default encoding for the machine, or on Silverlight, using U\+T\+F-\/8. This encoding is distinct from the encoding used for the filename itself. See \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}}. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em content} & The content of the file, should it be extracted from the zip. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad70399fae6bee75df23d40b96228f167}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad70399fae6bee75df23d40b96228f167}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [2/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{string}]{content,  }\item[{System.\+Text.\+Encoding}]{encoding }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given string as content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. 

Calling this method is equivalent to removing the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} for the given file name and directory path, if it exists, and then calling Add\+Entry(\+String,\+String, System.\+Text.\+Encoding). See the documentation for that method for further explanation. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em content} & The content of the file, should it be extracted from the zip. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em encoding} & The text encoding to use when encoding the string. Be aware\+: This is distinct from the text encoding used to encode the filename. See \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}}. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a632235fdf4c9592741f1a736a6b484a4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a632235fdf4c9592741f1a736a6b484a4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [3/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83a6b1de844c6db599faedbfc860c6744f6}{Write\+Delegate}}}]{writer }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given delegate as the source for content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. 

Calling this method is equivalent to removing the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} for the given file name and directory path, if it exists, and then calling Add\+Entry(\+String,\+Write\+Delegate). See the documentation for that method for further explanation. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em writer} & the delegate which will write the entry content.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a99b7c52499dded09ebea471c35ab04ce}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a99b7c52499dded09ebea471c35ab04ce}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [4/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a02583f9b7b1b724562c5ead6715256f2}{Open\+Delegate}}}]{opener,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a19b625523fef0bcff4722ebb8a04b5d0}{Close\+Delegate}}}]{closer }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given delegates to open and close the stream that provides the content for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}. 

Calling this method is equivalent to removing the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} for the given file name and directory path, if it exists, and then calling Add\+Entry(\+String,\+Open\+Delegate, Close\+Delegate). See the documentation for that method for further explanation. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em opener} & the delegate that will be invoked to open the stream \\
\hline
{\em closer} & the delegate that will be invoked to close the stream \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added or updated.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb3ebc0df8d7fa7d039eba7292e71330}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb3ebc0df8d7fa7d039eba7292e71330}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [5/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a9ced5352c56e7e0fceff15b534073c83aeae835e83c0494a376229f254f7d3392}{Stream}}}]{stream }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given stream as input, and the given filename and given directory Path. 

Calling the method is equivalent to calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}{Remove\+Entry()}}} if an entry by the same name already exists, and then calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{Add\+Entry()}}} with the given {\ttfamily file\+Name} and stream. 

The stream must be open and readable during the call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save}}}. You can dispense the stream on a just-\/in-\/time basis using the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9c5db72a0ee3dad46be934c75ffcfe91}{Zip\+Entry.\+Input\+Stream}} property. Check the documentation of that property for more information. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5ae21397e59e0699aa8701822477e537}{Ionic.\+Zip.\+Zip\+File.\+Add\+Entry(string, System.\+I\+O.\+Stream)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a9c5db72a0ee3dad46be934c75ffcfe91}{Ionic.\+Zip.\+Zip\+Entry.\+Input\+Stream}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em stream} & The input stream from which to read file data.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9a344d2fa379b4b020119d64b1f8e5f0}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9a344d2fa379b4b020119d64b1f8e5f0}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Entry@{Update\+Entry}}
\index{Update\+Entry@{Update\+Entry}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Entry()}{UpdateEntry()}\hspace{0.1cm}{\footnotesize\ttfamily [6/6]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Entry (\begin{DoxyParamCaption}\item[{string}]{entry\+Name,  }\item[{byte \mbox{[}$\,$\mbox{]}}]{byte\+Content }\end{DoxyParamCaption})}



Updates the given entry in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the given byte array as content for the entry. 

Calling this method is equivalent to removing the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} for the given filename and directory path, if it exists, and then calling Add\+Entry(\+String,byte\mbox{[}$\,$\mbox{]}). See the documentation for that method for further explanation. 


\begin{DoxyParams}{Parameters}
{\em entry\+Name} & The name, including any path, to use within the archive for the entry. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em byte\+Content} & The content to use for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}.\\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added.
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+File@{Update\+File}}
\index{Update\+File@{Update\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+File()}{UpdateFile()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name }\end{DoxyParamCaption})}



Adds or Updates a File in a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. 

This method adds a file to a zip archive, or, if the file already exists in the zip archive, this method Updates the content of that given filename in the zip archive. The {\ttfamily Update\+File} method might more accurately be called \char`\"{}\+Add\+Or\+Update\+File\char`\"{}. 

Upon success, there is no way for the application to learn whether the file was added versus updated. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

This example shows how to Update an existing entry in a zipfile. The first call to Update\+File adds the file to the newly-\/created zip archive. The second call to Update\+File updates the content for that file in the zip archive.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip1 = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
  \textcolor{comment}{// UpdateFile might more accurately be called "AddOrUpdateFile"}
  zip1.UpdateFile(\textcolor{stringliteral}{"MyDocuments\(\backslash\)\(\backslash\)Readme.txt"});
  zip1.UpdateFile(\textcolor{stringliteral}{"CustomerList.csv"});
  zip1.Comment = \textcolor{stringliteral}{"This zip archive has been created."};
  zip1.Save(\textcolor{stringliteral}{"Content.zip"});
\}

\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip2 = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"Content.zip"}))
\{
  zip2.UpdateFile(\textcolor{stringliteral}{"Updates\(\backslash\)\(\backslash\)Readme.txt"});
  zip2.Comment = \textcolor{stringliteral}{"This zip archive has been updated: The Readme.txt file has been changed."};
  zip2.Save();
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip1 As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    \textcolor{stringliteral}{' UpdateFile might more accurately be called "AddOrUpdateFile"}
\textcolor{stringliteral}{    zip1.UpdateFile("MyDocuments\(\backslash\)Readme.txt")}
\textcolor{stringliteral}{    zip1.UpdateFile("CustomerList.csv")}
\textcolor{stringliteral}{    zip1.Comment = "This zip archive has been created."}
\textcolor{stringliteral}{    zip1.Save("Content.zip")}
\textcolor{stringliteral}{End Using}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{Using zip2 As ZipFile = ZipFile.Read("Content.zip")}
\textcolor{stringliteral}{    zip2.UpdateFile("Updates\(\backslash\)Readme.txt")}
\textcolor{stringliteral}{    zip2.Comment = "This zip archive has been updated: The Readme.txt file has been changed."}
\textcolor{stringliteral}{    zip2.Save}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Ionic.\+Zip.\+Zip\+File.\+Add\+File(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file to add or update. It should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the File that was added or updated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5acb9856007c971996495db1ffd8f063}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5acb9856007c971996495db1ffd8f063}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+File@{Update\+File}}
\index{Update\+File@{Update\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+File()}{UpdateFile()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+File (\begin{DoxyParamCaption}\item[{string}]{file\+Name,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds or Updates a File in a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file archive. 

This method adds a file to a zip archive, or, if the file already exists in the zip archive, this method Updates the content of that given filename in the zip archive. 

This version of the method allows the caller to explicitly specify the directory path to be used in the archive. The entry to be added or updated is found by using the specified directory path, combined with the basename of the specified filename. 

Upon success, there is no way for the application to learn if the file was added versus updated. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+File(string,string), Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string,string), \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Item(string,string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file to add or update. It should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the {\ttfamily file\+Name}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on the {\ttfamily file\+Name}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} corresponding to the File that was added or updated. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4904d47eb715c7c6188e067c7142e1a6}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4904d47eb715c7c6188e067c7142e1a6}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Files@{Update\+Files}}
\index{Update\+Files@{Update\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Files()}{UpdateFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Files (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$}]{file\+Names }\end{DoxyParamCaption})}



Adds or updates a set of files in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

Any files that already exist in the archive are updated. Any files that don\textquotesingle{}t yet exist in the archive are added. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 


\begin{DoxyParams}{Parameters}
{\em file\+Names} & The collection of names of the files to update. Each string should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae27ba30d3eb9d3c97aa4e89684f9f56a}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae27ba30d3eb9d3c97aa4e89684f9f56a}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Files@{Update\+Files}}
\index{Update\+Files@{Update\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Files()}{UpdateFiles()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Files (\begin{DoxyParamCaption}\item[{System.\+Collections.\+Generic.\+I\+Enumerable$<$ String $>$}]{file\+Names,  }\item[{String}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Adds or updates a set of files to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using the specified directory path in the archive. 

Any files that already exist in the archive are updated. Any files that don\textquotesingle{}t yet exist in the archive are added. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} added. 


\begin{DoxyParams}{Parameters}
{\em file\+Names} & The names of the files to add or update. Each string should refer to a file in the filesystem. The name of the file may be a relative path or a fully-\/qualified path. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the file name. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on each of the {\ttfamily file\+Names}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac40d1b5cde5fe68a968056fe0f401359}{Ionic.\+Zip.\+Zip\+File.\+Add\+Selected\+Files(\+String, String)}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acb868d0e8711037cdfa9c4494c082d1c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Item@{Update\+Item}}
\index{Update\+Item@{Update\+Item}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Item()}{UpdateItem()}\hspace{0.1cm}{\footnotesize\ttfamily [1/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Item (\begin{DoxyParamCaption}\item[{string}]{item\+Name }\end{DoxyParamCaption})}



Add or update a file or directory in the zip archive. 

This is useful when the application is not sure or does not care if the item to be added is a file or directory, and does not know or does not care if the item already exists in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. Calling this method is equivalent to calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}{Remove\+Entry()}}} if an entry by the same name already exists, followed calling by {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Add\+Item()}}}. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af0f968c16a51dc151e2a553499e68c6a}{Ionic.\+Zip.\+Zip\+File.\+Update\+File(string)}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae8963f67f9d797697a053365b146219c}{Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string)}}


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em item\+Name} & the path to the file or directory to be added or updated. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac872f0efbde27717afb736a7d3833d3c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Item@{Update\+Item}}
\index{Update\+Item@{Update\+Item}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Item()}{UpdateItem()}\hspace{0.1cm}{\footnotesize\ttfamily [2/2]}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Item (\begin{DoxyParamCaption}\item[{string}]{item\+Name,  }\item[{string}]{directory\+Path\+In\+Archive }\end{DoxyParamCaption})}



Add or update a file or directory. 

This method is useful when the application is not sure or does not care if the item to be added is a file or directory, and does not know or does not care if the item already exists in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. Calling this method is equivalent to calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_adc89fc6cc55422a648f860be36d6c02f}{Remove\+Entry()}}}, if an entry by that name exists, and then calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a898561fe6436e1a87b628dff27633d55}{Add\+Item()}}}. 

This version of the method allows the caller to explicitly specify the directory path to be used for the item being added to the archive. The entry or entries that are added or updated will use the specified {\ttfamily Directory\+Path\+In\+Archive}. Extracting the entry from the archive will result in a file stored in that directory path. 

For {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} properties including \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}{Set\+Compression}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}{Extract\+Existing\+File}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, their respective values at the time of this call will be applied to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} added. 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Add\+Item(string, string), Ionic.\+Zip.\+Zip\+File.\+Update\+File(string, string), Ionic.\+Zip.\+Zip\+File.\+Update\+Directory(string, string)


\end{DoxySeeAlso}



\begin{DoxyParams}{Parameters}
{\em item\+Name} & The path for the File or Directory to be added or updated. \\
\hline
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to override any path in the {\ttfamily item\+Name}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing {\ttfamily null} ({\ttfamily Nothing} in VB) will use the path on the {\ttfamily item\+Name}, if any. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8695fef401b3f72d145ac634bf54a154}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8695fef401b3f72d145ac634bf54a154}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Update\+Selected\+Files@{Update\+Selected\+Files}}
\index{Update\+Selected\+Files@{Update\+Selected\+Files}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Update\+Selected\+Files()}{UpdateSelectedFiles()}}
{\footnotesize\ttfamily void Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Update\+Selected\+Files (\begin{DoxyParamCaption}\item[{String}]{selection\+Criteria,  }\item[{String}]{directory\+On\+Disk,  }\item[{String}]{directory\+Path\+In\+Archive,  }\item[{bool}]{recurse\+Directories }\end{DoxyParamCaption})}



Updates the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} with a selection of files from the disk that conform to the specified criteria. 

This method selects files from the specified disk directory that match the specified selection criteria, and Updates the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} with those files, using the specified directory path in the archive. If {\ttfamily recurse\+Directories} is true, files are also selected from subdirectories, and the directory structure in the filesystem is reproduced in the zip archive, rooted at the directory specified by {\ttfamily directory\+On\+Disk}. For details on the syntax for the selection\+Criteria parameter, see \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aad821b2bd7696468926572bbc22280ca}{Add\+Selected\+Files(\+String)}}. 


\begin{DoxyParams}{Parameters}
{\em selection\+Criteria} & The criteria for selection of files to add to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+On\+Disk} & The path to the directory in the filesystem from which to select files. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em directory\+Path\+In\+Archive} & Specifies a directory path to use to in place of the {\ttfamily directory\+On\+Disk}. This path may, or may not, correspond to a real directory in the current filesystem. If the files within the zip are later extracted, this is the path used for the extracted file. Passing null (nothing in VB) will use the path on the file name, if any; in other words it would use {\ttfamily directory\+On\+Disk}, plus any subdirectory. Passing the empty string (\char`\"{}\char`\"{}) will insert the item at the root path within the archive. \\
\hline
\end{DoxyParams}



\begin{DoxyParams}{Parameters}
{\em recurse\+Directories} & If true, the method also scans subdirectories for files matching the criteria. \\
\hline
\end{DoxyParams}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a95106f452f2326adb48fc72d1450a15e}{Add\+Selected\+Files(\+String, String, String, bool)}}


\end{DoxySeeAlso}


\subsection{Member Data Documentation}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9b06e16fba338b0ab3d2011d0b5b3aad}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9b06e16fba338b0ab3d2011d0b5b3aad}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Buffer\+Size\+Default@{Buffer\+Size\+Default}}
\index{Buffer\+Size\+Default@{Buffer\+Size\+Default}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Buffer\+Size\+Default}{BufferSizeDefault}}
{\footnotesize\ttfamily readonly int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Buffer\+Size\+Default = 32768\hspace{0.3cm}{\ttfamily [static]}}



Default size of the buffer used for IO. 



\subsection{Property Documentation}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad77f3a44b8c4de55ea960a9def4181ef}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad77f3a44b8c4de55ea960a9def4181ef}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Directory\+Will\+Traverse\+Reparse\+Points@{Add\+Directory\+Will\+Traverse\+Reparse\+Points}}
\index{Add\+Directory\+Will\+Traverse\+Reparse\+Points@{Add\+Directory\+Will\+Traverse\+Reparse\+Points}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Directory\+Will\+Traverse\+Reparse\+Points}{AddDirectoryWillTraverseReparsePoints}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Directory\+Will\+Traverse\+Reparse\+Points\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Indicates whether N\+T\+FS Reparse Points, like junctions, should be traversed during calls to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}}}. 

By default, calls to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}} will traverse N\+T\+FS reparse points, like mounted volumes, and directory junctions. An example of a junction is the \char`\"{}\+My Music\char`\"{} directory in Windows Vista. In some cases you may not want Dot\+Net\+Zip to traverse those directories. In that case, set this property to false. 


\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddDirectoryWillTraverseReparsePoints = \textcolor{keyword}{false};
    zip.AddDirectory(dirToZip,\textcolor{stringliteral}{"fodder"});
    zip.Save(zipFileToCreate);
\}
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Alternate\+Encoding@{Alternate\+Encoding}}
\index{Alternate\+Encoding@{Alternate\+Encoding}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Alternate\+Encoding}{AlternateEncoding}}
{\footnotesize\ttfamily System.\+Text.\+Encoding Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Alternate\+Encoding\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



A Text \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_encoding}{Encoding}} to use when encoding the filenames and comments for all the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items, during a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} operation. 

Whether the encoding specified here is used during the save depends on \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}{Alternate\+Encoding\+Usage}}. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Alternate\+Encoding\+Usage@{Alternate\+Encoding\+Usage}}
\index{Alternate\+Encoding\+Usage@{Alternate\+Encoding\+Usage}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Alternate\+Encoding\+Usage}{AlternateEncodingUsage}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a25d431031427c142eba970006eee630c}{Zip\+Option}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Alternate\+Encoding\+Usage\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



A flag that tells if and when this instance should apply Alternate\+Encoding to encode the filenames and comments associated to of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} objects contained within this instance. 

\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Buffer\+Size@{Buffer\+Size}}
\index{Buffer\+Size@{Buffer\+Size}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Buffer\+Size}{BufferSize}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Buffer\+Size\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Size of the IO buffer used while saving. 

First, let me say that you really don\textquotesingle{}t need to bother with this. It is here to allow for optimizations that you probably won\textquotesingle{}t make! It will work fine if you don\textquotesingle{}t set or get this property at all. Ok? 

Now that we have {\itshape that} out of the way, the fine print\+: This property affects the size of the buffer that is used for I/O for each entry contained in the zip file. When a file is read in to be compressed, it uses a buffer given by the size here. When you update a zip file, the data for unmodified entries is copied from the first zip file to the other, through a buffer given by the size here. 

Changing the buffer size affects a few things\+: first, for larger buffer sizes, the memory used by the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, obviously, will be larger during I/O operations. This may make operations faster for very much larger files. Last, for any given entry, when you use a larger buffer there will be fewer progress events during I/O operations, because there\textquotesingle{}s one progress event generated for each time the buffer is filled and then emptied. 

The default buffer size is 8k. Increasing the buffer size may speed things up as you compress larger files. But there are no hard-\/and-\/fast rules here, eh? You won\textquotesingle{}t know til you test it. And there will be a limit where ever larger buffers actually slow things down. So as I said in the beginning, it\textquotesingle{}s probably best if you don\textquotesingle{}t set or get this property at all. 

This example shows how you might set a large buffer size for efficiency when dealing with zip entries that are larger than 1gb. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.SaveProgress += this.zip1\_SaveProgress;
    zip.AddDirectory(directoryToZip, \textcolor{stringliteral}{""});
    zip.UseZip64WhenSaving = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64Option}}.Always;
    zip.BufferSize = 65536*8; \textcolor{comment}{// 65536 * 8 = 512k}
    zip.Save(ZipFileToCreate);
\}
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeb25467e1a84cabe712c5a30603d3bf6}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeb25467e1a84cabe712c5a30603d3bf6}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Case\+Sensitive\+Retrieval@{Case\+Sensitive\+Retrieval}}
\index{Case\+Sensitive\+Retrieval@{Case\+Sensitive\+Retrieval}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Case\+Sensitive\+Retrieval}{CaseSensitiveRetrieval}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Case\+Sensitive\+Retrieval\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Indicates whether to perform case-\/sensitive matching on the filename when retrieving entries in the zipfile via the string-\/based indexer. 

The default value is {\ttfamily false}, which means don\textquotesingle{}t do case-\/sensitive matching. In other words, retrieving zip\mbox{[}\char`\"{}\+Read\+Me.\+Txt\char`\"{}\mbox{]} is the same as zip\mbox{[}\char`\"{}readme.\+txt\char`\"{}\mbox{]}. It really makes sense to set this to {\ttfamily true} only if you are not running on Windows, which has case-\/insensitive filenames. But since this library is not built for non-\/\+Windows platforms, in most cases you should just leave this property alone. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7224a4ba799edb3d0e3c47ada11eeb8c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7224a4ba799edb3d0e3c47ada11eeb8c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Codec\+Buffer\+Size@{Codec\+Buffer\+Size}}
\index{Codec\+Buffer\+Size@{Codec\+Buffer\+Size}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Codec\+Buffer\+Size}{CodecBufferSize}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Codec\+Buffer\+Size\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Size of the work buffer to use for the Z\+L\+IB codec during compression. 

When doing Z\+L\+IB or Deflate compression, the library fills a buffer, then passes it to the compressor for compression. Then the library reads out the compressed bytes. This happens repeatedly until there is no more uncompressed data to compress. This property sets the size of the buffer that will be used for chunk-\/wise compression. In order for the setting to take effect, your application needs to set this property before calling one of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}} overloads. 

Setting this affects the performance and memory efficiency of compression and decompression. For larger files, setting this to a larger size may improve compression performance, but the exact numbers vary depending on available memory, the size of the streams you are compressing, and a bunch of other variables. I don\textquotesingle{}t have good firm recommendations on how to set it. You\textquotesingle{}ll have to test it yourself. Or just leave it alone and accept the default. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Comment@{Comment}}
\index{Comment@{Comment}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Comment}{Comment}}
{\footnotesize\ttfamily string Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Comment\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



A comment attached to the zip archive. 

This property is read/write. It allows the application to specify a comment for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, or read the comment for the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. After setting this property, changes are only made permanent when you call a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} method. 

According to P\+K\+W\+A\+RE\textquotesingle{}s zip specification

, the comment is not encrypted, even if there is a password set on the zip file. 

The specification does not describe how to indicate the encoding used on a comment string. Many \char`\"{}compliant\char`\"{} zip tools and libraries use I\+B\+M437 as the code page for comments; Dot\+Net\+Zip, too, follows that practice. On the other hand, there are situations where you want a Comment to be encoded with something else, for example using code page 950 \char`\"{}\+Big-\/5 Chinese\char`\"{}. To fill that need, Dot\+Net\+Zip will encode the comment following the same procedure it follows for encoding filenames\+: (a) if \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}{Alternate\+Encoding\+Usage}} is {\ttfamily Never}, it uses the default encoding (I\+B\+M437). (b) if \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}{Alternate\+Encoding\+Usage}} is {\ttfamily Always}, it always uses the alternate encoding (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}}). (c) if \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abfa9e860cc57465297df205d1d48a616}{Alternate\+Encoding\+Usage}} is {\ttfamily As\+Necessary}, it uses the alternate encoding only if the default encoding is not sufficient for encoding the comment -\/ in other words if decoding the result does not produce the original string. This decision is taken at the time of the call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}. 

When creating a zip archive using this library, it is possible to change the value of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}} between each entry you add, and between adding entries and the call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. Don\textquotesingle{}t do this. It will likely result in a zip file that is not readable by any tool or application. For best interoperability, leave \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5fbf6af29062f76b6ce06c6197ff6c8b}{Alternate\+Encoding}} alone, or specify it only once, before adding any entries to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Compression\+Level@{Compression\+Level}}
\index{Compression\+Level@{Compression\+Level}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Compression\+Level}{CompressionLevel}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_a20f6771804996c363f454ad9765cd7db}{Ionic.\+Zlib.\+Compression\+Level}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Compression\+Level\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Sets the compression level to be used for entries subsequently added to the zip archive. 

Varying the compression level used on entries can affect the size-\/vs-\/speed tradeoff when compression and decompressing data streams or files. 

As with some other properties on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class, like \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+Error\+Action}}, setting this property on a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance will cause the specified {\ttfamily Compression\+Level} to be used on all \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items that are subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. If you set this property after you have added items to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, but before you have called {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, those items will not use the specified compression level. 

If you do not set this property, the default compression level is used, which normally gives a good balance of compression efficiency and compression speed. In some tests, using {\ttfamily Best\+Compression} can double the time it takes to compress, while delivering just a small increase in compression efficiency. This behavior will vary with the type of data you compress. If you are in doubt, just leave this setting alone, and accept the default. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3fa017cd62445ff4041b5958dfb4ab2e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3fa017cd62445ff4041b5958dfb4ab2e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Compression\+Method@{Compression\+Method}}
\index{Compression\+Method@{Compression\+Method}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Compression\+Method}{CompressionMethod}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a48fd7a4529dd87fb2fda54f62ae3d8a3}{Ionic.\+Zip.\+Compression\+Method}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Compression\+Method\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The compression method for the zipfile. 

By default, the compression method is {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a48fd7a4529dd87fb2fda54f62ae3d8a3ae2430ff724c45c3d68893fb1a3584426}{Compression\+Method.\+Deflate}}.} 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a48fd7a4529dd87fb2fda54f62ae3d8a3}{Ionic.\+Zip.\+Compression\+Method}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab47cd362deaea15bb16ecc8654391d6b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab47cd362deaea15bb16ecc8654391d6b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Count@{Count}}
\index{Count@{Count}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Count}{Count}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Count\hspace{0.3cm}{\ttfamily [get]}}



Returns the number of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. 

\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a55217486008cf80cba92210c592471f1}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a55217486008cf80cba92210c592471f1}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Default\+Encoding@{Default\+Encoding}}
\index{Default\+Encoding@{Default\+Encoding}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Default\+Encoding}{DefaultEncoding}}
{\footnotesize\ttfamily System.\+Text.\+Encoding Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Default\+Encoding\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



The default text encoding used in zip archives. It is numeric 437, also known as I\+B\+M437. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Ionic.\+Zip.\+Zip\+File.\+Provisional\+Alternate\+Encoding}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af369a36c1bf83fc28466fe15c095ea87}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af369a36c1bf83fc28466fe15c095ea87}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Emit\+Times\+In\+Unix\+Format\+When\+Saving@{Emit\+Times\+In\+Unix\+Format\+When\+Saving}}
\index{Emit\+Times\+In\+Unix\+Format\+When\+Saving@{Emit\+Times\+In\+Unix\+Format\+When\+Saving}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Emit\+Times\+In\+Unix\+Format\+When\+Saving}{EmitTimesInUnixFormatWhenSaving}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Emit\+Times\+In\+Unix\+Format\+When\+Saving\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Specifies whether the Creation, Access, and Modified times for entries added to the zip file will be emitted in \char`\"{}\+Unix(tm)
format\char`\"{} when the zip archive is saved. 

An application creating a zip archive can use this flag to explicitly specify that the file times for the entries should or should not be stored in the zip archive in the format used by Unix. By default this flag is {\ttfamily false}, meaning the Unix-\/format times are not stored in the zip archive. 

When adding an entry from a file or directory, the Creation (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a38ef2ae810c3b89b1f23ebea918fb60e}{Zip\+Entry.\+Creation\+Time}}), Access (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_abc1a038c251f1ed0e2c1435a5bab23fd}{Zip\+Entry.\+Accessed\+Time}}), and Modified (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a88021d72ea8b94c762388d92d74c2e0d}{Zip\+Entry.\+Modified\+Time}}) times for the given entry are automatically set from the filesystem values. When adding an entry from a stream or string, all three values are implicitly set to Date\+Time.\+Now. Applications can also explicitly set those times by calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a7331ca69b05c476a9d321b30d7649766}{Zip\+Entry.\+Set\+Entry\+Times(\+Date\+Time, Date\+Time, Date\+Time)}}. 

P\+K\+W\+A\+RE\textquotesingle{}s zip specification

describes multiple ways to format these times in a zip file. One is the format Windows applications normally use\+: 100ns ticks since January 1, 1601 U\+TC. The other is a format Unix applications typically use\+: seconds since January 1, 1970 U\+TC. Each format can be stored in an \char`\"{}extra field\char`\"{} in the zip entry when saving the zip archive. The former uses an extra field with a Header Id of 0x000A, while the latter uses a header ID of 0x5455, although you probably don\textquotesingle{}t need to know that. 

Not all tools and libraries can interpret these fields. Windows compressed folders is one that can read the Windows Format timestamps, while I believe the Infozip

tools can read the Unix format timestamps. Some tools and libraries may be able to read only one or the other. Dot\+Net\+Zip can read or write times in either or both formats. 

The times stored are taken from \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a88021d72ea8b94c762388d92d74c2e0d}{Zip\+Entry.\+Modified\+Time}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_abc1a038c251f1ed0e2c1435a5bab23fd}{Zip\+Entry.\+Accessed\+Time}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a38ef2ae810c3b89b1f23ebea918fb60e}{Zip\+Entry.\+Creation\+Time}}. 

This property is not mutually exclusive of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1695d2181d639029b132e67c85734e8c}{Emit\+Times\+In\+Windows\+Format\+When\+Saving}} property. It is possible and legal and valid to produce a zip file that contains timestamps encoded in the Unix format as well as in the Windows format, in addition to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_acd1234fd27c216b59c166c2b96aba3dd}{Last\+Modified}} time attached to each entry in the zip archive, a time that is always stored in \char`\"{}\+D\+O\+S
  format\char`\"{}. And, notwithstanding the names P\+K\+Ware uses for these time formats, any of them can be read and written by any computer, on any operating system. But, there are no guarantees that a program running on Mac or Linux will gracefully handle a zip file with \char`\"{}\+Windows\char`\"{} formatted times, or that an application that does not use Dot\+Net\+Zip but runs on Windows will be able to handle file times in Unix format. 

When in doubt, test. Sorry, I haven\textquotesingle{}t got a complete list of tools and which sort of timestamps they can use and will tolerate. If you get any good information and would like to pass it on, please do so and I will include that information in this documentation. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_afd50bda347e67681780f32ebdba43f58}{Zip\+Entry.\+Emit\+Times\+In\+Unix\+Format\+When\+Saving}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1695d2181d639029b132e67c85734e8c}{Emit\+Times\+In\+Windows\+Format\+When\+Saving}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1695d2181d639029b132e67c85734e8c}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a1695d2181d639029b132e67c85734e8c}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Emit\+Times\+In\+Windows\+Format\+When\+Saving@{Emit\+Times\+In\+Windows\+Format\+When\+Saving}}
\index{Emit\+Times\+In\+Windows\+Format\+When\+Saving@{Emit\+Times\+In\+Windows\+Format\+When\+Saving}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Emit\+Times\+In\+Windows\+Format\+When\+Saving}{EmitTimesInWindowsFormatWhenSaving}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Emit\+Times\+In\+Windows\+Format\+When\+Saving\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Specifies whether the Creation, Access, and Modified times for entries added to the zip file will be emitted in \&\#147;Windows format\&\#148; when the zip archive is saved. 

An application creating a zip archive can use this flag to explicitly specify that the file times for the entries should or should not be stored in the zip archive in the format used by Windows. By default this flag is {\ttfamily true}, meaning the Windows-\/format times are stored in the zip archive. 

When adding an entry from a file or directory, the Creation (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a38ef2ae810c3b89b1f23ebea918fb60e}{Zip\+Entry.\+Creation\+Time}}), Access (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_abc1a038c251f1ed0e2c1435a5bab23fd}{Zip\+Entry.\+Accessed\+Time}}), and Modified (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a88021d72ea8b94c762388d92d74c2e0d}{Zip\+Entry.\+Modified\+Time}}) times for the given entry are automatically set from the filesystem values. When adding an entry from a stream or string, all three values are implicitly set to {\ttfamily Date\+Time.\+Now}. Applications can also explicitly set those times by calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a7331ca69b05c476a9d321b30d7649766}{Zip\+Entry.\+Set\+Entry\+Times(\+Date\+Time, Date\+Time,
  Date\+Time)}}. 

P\+K\+W\+A\+RE\textquotesingle{}s zip specification

describes multiple ways to format these times in a zip file. One is the format Windows applications normally use\+: 100ns ticks since January 1, 1601 U\+TC. The other is a format Unix applications typically use\+: seconds since January 1, 1970 U\+TC. Each format can be stored in an \char`\"{}extra field\char`\"{} in the zip entry when saving the zip archive. The former uses an extra field with a Header Id of 0x000A, while the latter uses a header ID of 0x5455, although you probably don\textquotesingle{}t need to know that. 

Not all tools and libraries can interpret these fields. Windows compressed folders is one that can read the Windows Format timestamps, while I believe the Infozip tools

can read the Unix format timestamps. Some tools and libraries may be able to read only one or the other. Dot\+Net\+Zip can read or write times in either or both formats. 

The times stored are taken from \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a88021d72ea8b94c762388d92d74c2e0d}{Zip\+Entry.\+Modified\+Time}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_abc1a038c251f1ed0e2c1435a5bab23fd}{Zip\+Entry.\+Accessed\+Time}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a38ef2ae810c3b89b1f23ebea918fb60e}{Zip\+Entry.\+Creation\+Time}}. 

The value set here applies to all entries subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

This property is not mutually exclusive of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af369a36c1bf83fc28466fe15c095ea87}{Emit\+Times\+In\+Unix\+Format\+When\+Saving}} property. It is possible and legal and valid to produce a zip file that contains timestamps encoded in the Unix format as well as in the Windows format, in addition to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_acd1234fd27c216b59c166c2b96aba3dd}{Last\+Modified}} time attached to each entry in the archive, a time that is always stored in \char`\"{}\+D\+O\+S format\char`\"{}. And, notwithstanding the names P\+K\+Ware uses for these time formats, any of them can be read and written by any computer, on any operating system. But, there are no guarantees that a program running on Mac or Linux will gracefully handle a zip file with \char`\"{}\+Windows\char`\"{} formatted times, or that an application that does not use Dot\+Net\+Zip but runs on Windows will be able to handle file times in Unix format. 

When in doubt, test. Sorry, I haven\textquotesingle{}t got a complete list of tools and which sort of timestamps they can use and will tolerate. If you get any good information and would like to pass it on, please do so and I will include that information in this documentation. 

This example shows how to save a zip file that contains file timestamps in a format normally used by Unix. 
\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    \textcolor{comment}{// produce a zip file the Mac will like}
    zip.EmitTimesInWindowsFormatWhenSaving = \textcolor{keyword}{false};
    zip.EmitTimesInUnixFormatWhenSaving = \textcolor{keyword}{true};
    zip.AddDirectory(directoryToZip, \textcolor{stringliteral}{"files"});
    zip.Save(outputFile);
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    \textcolor{stringliteral}{''} produce a zip file the Mac will like
    zip.EmitTimesInWindowsFormatWhenSaving = False
    zip.EmitTimesInUnixFormatWhenSaving = True
    zip.AddDirectory(directoryToZip, \textcolor{stringliteral}{"files"})
    zip.Save(outputFile)
End Using
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_affabc22ba72be27e9134676becddcec7}{Zip\+Entry.\+Emit\+Times\+In\+Windows\+Format\+When\+Saving}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_af369a36c1bf83fc28466fe15c095ea87}{Emit\+Times\+In\+Unix\+Format\+When\+Saving}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Encryption@{Encryption}}
\index{Encryption@{Encryption}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Encryption}{Encryption}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa3f4e8aa12ef827ac72177a49b4e28e6}{Encryption\+Algorithm}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Encryption\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The Encryption to use for entries added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

Set this when creating a zip archive, or when updating a zip archive. The specified Encryption is applied to the entries subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. Applications do not need to set the {\ttfamily Encryption} property when reading or extracting a zip archive. 

If you set this to something other than \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa3f4e8aa12ef827ac72177a49b4e28e6a6adf97f83acf6453d4a6a4b1070f3754}{Encryption\+Algorithm.\+None}}, you will also need to set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}. 

As with some other properties on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class, like \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}} and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, setting this property on a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance will cause the specified {\ttfamily Encryption\+Algorithm} to be used on all \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items that are subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. In other words, if you set this property after you have added items to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, but before you have called {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, those items will not be encrypted or protected with a password in the resulting zip archive. To get a zip archive with encrypted entries, set this property, along with the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}} property, before calling {\ttfamily Add\+File}, {\ttfamily Add\+Item}, or {\ttfamily Add\+Directory} (etc.) on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

If you read a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, you can modify the {\ttfamily Encryption} on an encrypted entry, only by setting the {\ttfamily Encryption} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} itself. Setting the {\ttfamily Encryption} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, once it has been created via a call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}}, does not affect entries that were previously read. 

For example, suppose you read a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, and there is an encrypted entry. Setting the {\ttfamily Encryption} property on that {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} and then calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} does not update the {\ttfamily Encryption} used for the entries in the archive. Neither is an exception thrown. Instead, what happens during the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} is that all previously existing entries are copied through to the new zip archive, with whatever encryption and password that was used when originally creating the zip archive. Upon re-\/reading that archive, to extract entries, applications should use the original password or passwords, if any. 

Suppose an application reads a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, and there is an encrypted entry. Setting the {\ttfamily Encryption} property on that {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} and then adding new entries (via {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File()}}}, {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7f8d10ab9f75f0de6d27a61e5466c210}{Add\+Entry()}}}, etc) and then calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} does not update the {\ttfamily Encryption} on any of the entries that had previously been in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. The {\ttfamily Encryption} property applies only to the newly-\/added entries. 

This example creates a zip archive that uses encryption, and then extracts entries from the archive. When creating the zip archive, the Read\+Me.\+txt file is zipped without using a password or encryption. The other files use encryption. 


\begin{DoxyCode}
\textcolor{comment}{// Create a zip archive with AES Encryption.}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddFile(\textcolor{stringliteral}{"ReadMe.txt"});
    zip.Encryption= \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa3f4e8aa12ef827ac72177a49b4e28e6}{EncryptionAlgorithm}}.WinZipAes256;
    zip.Password= \textcolor{stringliteral}{"Top.Secret.No.Peeking!"};
    zip.AddFile(\textcolor{stringliteral}{"7440-N49th.png"});
    zip.AddFile(\textcolor{stringliteral}{"2008-Regional-Sales-Report.pdf"});
    zip.Save(\textcolor{stringliteral}{"EncryptedArchive.zip"});
\}

\textcolor{comment}{// Extract a zip archive that uses AES Encryption.}
\textcolor{comment}{// You do not need to specify the algorithm during extraction.}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"EncryptedArchive.zip"}))
\{
    zip.Password= \textcolor{stringliteral}{"Top.Secret.No.Peeking!"};
    zip.ExtractAll(\textcolor{stringliteral}{"extractDirectory"});
\}
\end{DoxyCode}



\begin{DoxyCode}
\textcolor{stringliteral}{' Create a zip that uses Encryption.}
\textcolor{stringliteral}{Using zip As New ZipFile()}
\textcolor{stringliteral}{    zip.Encryption= EncryptionAlgorithm.WinZipAes256}
\textcolor{stringliteral}{    zip.Password= "Top.Secret.No.Peeking!"}
\textcolor{stringliteral}{    zip.AddFile("ReadMe.txt")}
\textcolor{stringliteral}{    zip.AddFile("7440-N49th.png")}
\textcolor{stringliteral}{    zip.AddFile("2008-Regional-Sales-Report.pdf")}
\textcolor{stringliteral}{    zip.Save("EncryptedArchive.zip")}
\textcolor{stringliteral}{End Using}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{'} Extract a zip archive that uses AES \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}.
\textcolor{stringliteral}{' You do not need to specify the algorithm during extraction.}
\textcolor{stringliteral}{Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))}
\textcolor{stringliteral}{    zip.Password= "Top.Secret.No.Peeking!"}
\textcolor{stringliteral}{    zip.ExtractAll("extractDirectory")}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Ionic.\+Zip.\+Zip\+File.\+Password}}


\end{DoxySeeAlso}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Zip\+File.\+Password}}

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_ab8de4882ffe896d2657b27264807ef1c}{Ionic.\+Zip.\+Zip\+Entry.\+Encryption}}


\end{DoxySeeAlso}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_ab8de4882ffe896d2657b27264807ef1c}{Zip\+Entry.\+Encryption}}\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a09b9d3aecc21754ab8a9d950b20de72b}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a09b9d3aecc21754ab8a9d950b20de72b}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Entries@{Entries}}
\index{Entries@{Entries}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Entries}{Entries}}
{\footnotesize\ttfamily System.\+Collections.\+Generic.\+I\+Collection$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Entries\hspace{0.3cm}{\ttfamily [get]}}



Returns the readonly collection of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. 

If there are no entries in the current {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, the value returned is a non-\/null zero-\/element collection. If there are entries in the zip file, the elements are returned in no particular order. 

This is the implied enumerator on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class. If you use a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance in a context that expects an enumerator, you will get this collection. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad4da87108d27a1ee534a16333fa39fd7}{Entries\+Sorted}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad4da87108d27a1ee534a16333fa39fd7}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad4da87108d27a1ee534a16333fa39fd7}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Entries\+Sorted@{Entries\+Sorted}}
\index{Entries\+Sorted@{Entries\+Sorted}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Entries\+Sorted}{EntriesSorted}}
{\footnotesize\ttfamily System.\+Collections.\+Generic.\+I\+Collection$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Entries\+Sorted\hspace{0.3cm}{\ttfamily [get]}}



Returns a readonly collection of entries in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive, sorted by File\+Name. 

If there are no entries in the current {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, the value returned is a non-\/null zero-\/element collection. If there are entries in the zip file, the elements are returned sorted by the name of the entry. 

This example fills a Windows Forms List\+View with the entries in a zip file.


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipFile))
\{
    \textcolor{keywordflow}{foreach} (ZipEntry entry \textcolor{keywordflow}{in} zip.EntriesSorted)
    \{
        ListViewItem item = \textcolor{keyword}{new} ListViewItem(n.ToString());
        n++;
        \textcolor{keywordtype}{string}[] subitems = \textcolor{keyword}{new} \textcolor{keywordtype}{string}[] \{
            entry.FileName.Replace(\textcolor{stringliteral}{"/"},\textcolor{stringliteral}{"\(\backslash\)\(\backslash\)"}),
            entry.LastModified.ToString(\textcolor{stringliteral}{"yyyy-MM-dd HH:mm:ss"}),
            entry.UncompressedSize.ToString(),
            String.Format(\textcolor{stringliteral}{"\{0,5:F0\}%"}, entry.CompressionRatio),
            entry.CompressedSize.ToString(),
            (entry.UsesEncryption) ? \textcolor{stringliteral}{"Y"} : \textcolor{stringliteral}{"N"},
            String.Format(\textcolor{stringliteral}{"\{0:X8\}"}, entry.Crc)\};

        \textcolor{keywordflow}{foreach} (String s \textcolor{keywordflow}{in} subitems)
        \{
            ListViewItem.ListViewSubItem subitem = \textcolor{keyword}{new} ListViewItem.ListViewSubItem();
            subitem.Text = s;
            item.SubItems.Add(subitem);
        \}

        this.listView1.Items.Add(item);
    \}
\}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a09b9d3aecc21754ab8a9d950b20de72b}{Entries}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a978fb90dbd4c922c55921d1ae8f631d5}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a978fb90dbd4c922c55921d1ae8f631d5}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Entry\+File\+Names@{Entry\+File\+Names}}
\index{Entry\+File\+Names@{Entry\+File\+Names}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Entry\+File\+Names}{EntryFileNames}}
{\footnotesize\ttfamily System.\+Collections.\+Generic.\+I\+Collection$<$String$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Entry\+File\+Names\hspace{0.3cm}{\ttfamily [get]}}



The list of filenames for the entries contained within the zip archive. 

According to the Z\+IP specification, the names of the entries use forward slashes in pathnames. If you are scanning through the list, you may have to swap forward slashes for backslashes. 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+this\mbox{[}string\mbox{]}


\end{DoxySeeAlso}


This example shows one way to test if a filename is already contained within a zip archive. 
\begin{DoxyCode}
String zipFileToRead= \textcolor{stringliteral}{"PackedDocuments.zip"};
\textcolor{keywordtype}{string} candidate = \textcolor{stringliteral}{"DatedMaterial.xps"};
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}(zipFileToRead))
\{
  \textcolor{keywordflow}{if} (zip.EntryFilenames.Contains(candidate))
    Console.WriteLine(\textcolor{stringliteral}{"The file '\{0\}' exists in the zip archive '\{1\}'"},
                      candidate,
                      zipFileName);
  \textcolor{keywordflow}{else}
    Console.WriteLine(\textcolor{stringliteral}{"The file, '\{0\}', does not exist in the zip archive '\{1\}'"},
                      candidate,
                      zipFileName);
  Console.WriteLine();
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Dim zipFileToRead As String = \textcolor{stringliteral}{"PackedDocuments.zip"}
Dim candidate As String = \textcolor{stringliteral}{"DatedMaterial.xps"}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipFileToRead)
    If zip.EntryFilenames.Contains(candidate) Then
        Console.WriteLine(\textcolor{stringliteral}{"The file '\{0\}' exists in the zip archive '\{1\}'"}, \_
                    candidate, \_
                    zipFileName)
    Else
      Console.WriteLine(\textcolor{stringliteral}{"The file, '\{0\}', does not exist in the zip archive '\{1\}'"}, \_
                    candidate, \_
                    zipFileName)
    End If
    Console.WriteLine
End Using
\end{DoxyCode}
 

\begin{DoxyReturn}{Returns}
The list of strings for the filenames contained within the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab900ee0fb15ee35c3c76ef492ff2517f}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Existing\+File@{Extract\+Existing\+File}}
\index{Extract\+Existing\+File@{Extract\+Existing\+File}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Existing\+File}{ExtractExistingFile}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0}{Extract\+Existing\+File\+Action}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Existing\+File\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The action the library should take when extracting a file that already exists. 

This property affects the behavior of the Extract methods (one of the {\ttfamily Extract()} or {\ttfamily Extract\+With\+Password()} overloads), when extraction would would overwrite an existing filesystem file. If you do not set this property, the library throws an exception when extracting an entry would overwrite an existing file. 

This property has no effect when extracting to a stream, or when the file to be extracted does not already exist. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_ad1ab903c29b91edb82e7c6a9768552dd}{Ionic.\+Zip.\+Zip\+Entry.\+Extract\+Existing\+File}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0ce8fe1d66e96dc3deb4f2425573e567}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a0ce8fe1d66e96dc3deb4f2425573e567}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Full\+Scan@{Full\+Scan}}
\index{Full\+Scan@{Full\+Scan}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Full\+Scan}{FullScan}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Full\+Scan\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Indicates whether to perform a full scan of the zip file when reading it. 

You almost never want to use this property. 

When reading a zip file, if this flag is {\ttfamily true} ({\ttfamily True} in VB), the entire zip archive will be scanned and searched for entries. For large archives, this can take a very, long time. The much more efficient default behavior is to read the zip directory, which is stored at the end of the zip file. But, in some cases the directory is corrupted and you need to perform a full scan of the zip file to determine the contents of the zip file. This property lets you do that, when necessary. 

This flag is effective only when calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a2b07c611d58c3a2c0b59ec14eea02179}{Initialize(string)}}. Normally you would read a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} with the static \mbox{\hyperlink{}{Zip\+File.\+Read}} method. But you can\textquotesingle{}t set the {\ttfamily Full\+Scan} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance when you use a static factory method like {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read}}}. 

This example shows how to read a zip file using the full scan approach, and then save it, thereby producing a corrected zip file.


\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.FullScan = \textcolor{keyword}{true};
    zip.Initialize(zipFileName);
    zip.Save(newName);
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip.FullScan = True
    zip.Initialize(zipFileName)
    zip.Save(newName)
End Using
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae4fcb9391e4a839218b63c4c129883b3}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae4fcb9391e4a839218b63c4c129883b3}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Info@{Info}}
\index{Info@{Info}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Info}{Info}}
{\footnotesize\ttfamily string Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Info\hspace{0.3cm}{\ttfamily [get]}}



Provides a human-\/readable string with information about the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. 

The information string contains 10 lines or so, about each \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}, describing whether encryption is in use, the compressed and uncompressed length of the entry, the offset of the entry, and so on. As a result the information string can be very long for zip files that contain many entries. 

This information is mostly useful for diagnostic purposes. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a613f1159ee59c2ee7bf682567579ad09}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a613f1159ee59c2ee7bf682567579ad09}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Input\+Uses\+Zip64@{Input\+Uses\+Zip64}}
\index{Input\+Uses\+Zip64@{Input\+Uses\+Zip64}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Input\+Uses\+Zip64}{InputUsesZip64}}
{\footnotesize\ttfamily Nullable$<$bool$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Input\+Uses\+Zip64\hspace{0.3cm}{\ttfamily [get]}}



Indicates whether the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Read()}}} operation read a zip file that uses Z\+I\+P64 extensions. 

This property will return null (Nothing in VB) if you\textquotesingle{}ve added an entry after reading the zip file. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9c12c0e7927c8d1fff6abd5f80e1125}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ac9c12c0e7927c8d1fff6abd5f80e1125}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Library\+Version@{Library\+Version}}
\index{Library\+Version@{Library\+Version}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Library\+Version}{LibraryVersion}}
{\footnotesize\ttfamily System.\+Version Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Library\+Version\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [get]}}



Returns the version number on the Dot\+Net\+Zip assembly. 

This property is exposed as a convenience. Callers could also get the version value by retrieving Get\+Name().Version on the System.\+Reflection.\+Assembly object pointing to the Dot\+Net\+Zip assembly. But sometimes it is not clear which assembly is being loaded. This property makes it clear. 

This static property is primarily useful for diagnostic purposes. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Max\+Output\+Segment\+Size@{Max\+Output\+Segment\+Size}}
\index{Max\+Output\+Segment\+Size@{Max\+Output\+Segment\+Size}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Max\+Output\+Segment\+Size}{MaxOutputSegmentSize}}
{\footnotesize\ttfamily Int32 Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Max\+Output\+Segment\+Size\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The maximum size of an output segment, when saving a split \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file. 

Set this to a non-\/zero value before calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} or \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}{Save(\+String)}} to specify that the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} should be saved as a split archive, also sometimes called a spanned archive. Some also call them multi-\/file archives. 

A split zip archive is saved in a set of discrete filesystem files, rather than in a single file. This is handy when transmitting the archive in email or some other mechanism that has a limit to the size of each file. The first file in a split archive will be named {\ttfamily basename.\+z01}, the second will be named {\ttfamily basename.\+z02}, and so on. The final file is named {\ttfamily basename.\+zip}. According to the zip specification from P\+K\+Ware, the minimum value is 65536, for a 64k segment size. The maximum number of segments allows in a split archive is 99. 

The value of this property determines the maximum size of a split segment when writing a split archive. For example, suppose you have a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} that would save to a single file of 200k. If you set the {\ttfamily Max\+Output\+Segment\+Size} to 65536 before calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, you will get four distinct output files. On the other hand if you set this property to 256k, then you will get a single-\/file archive for that {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

The size of each split output file will be as large as possible, up to the maximum size set here. The zip specification requires that some data fields in a zip archive may not span a split boundary, and an output segment may be smaller than the maximum if necessary to avoid that problem. Also, obviously the final segment of the archive may be smaller than the maximum segment size. Segments will never be larger than the value set with this property. 

You can save a split \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} file only when saving to a regular filesystem file. It\textquotesingle{}s not possible to save a split zip file as a self-\/extracting archive, nor is it possible to save a split zip file to a stream. When saving to a S\+FX or to a Stream, this property is ignored. 

About interoperability\+: Split or spanned zip files produced by Dot\+Net\+Zip can be read by Win\+Zip or P\+K\+Zip, and vice-\/versa. Segmented zip files may not be readable by other tools, if those other tools don\textquotesingle{}t support zip spanning or splitting. When in doubt, test. I don\textquotesingle{}t believe Windows Explorer can extract a split archive. 

This property has no effect when reading a split archive. You can read a split archive in the normal way with Dot\+Net\+Zip. 

When saving a zip file, if you want a regular zip file rather than a split zip file, don\textquotesingle{}t set this property, or set it to Zero. 

If you read a split archive, with \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read(string)}} and then subsequently call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}, unless you set this property before calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, you will get a normal, single-\/file archive. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7968b0265bacd1a670497fd87c824cef}{Number\+Of\+Segments\+For\+Most\+Recent\+Save}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Name@{Name}}
\index{Name@{Name}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Name}{Name}}
{\footnotesize\ttfamily string Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Name\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The name of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, on disk. 

When the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance was created by reading an archive using one of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read}}} methods, this property represents the name of the zip file that was read. When the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance was created by using the no-\/argument constructor, this value is {\ttfamily null} ({\ttfamily Nothing} in VB). 

If you use the no-\/argument constructor, and you then explicitly set this property, when you call \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}, this name will specify the name of the zip file created. Doing so is equivalent to calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}{Zip\+File.\+Save(\+String)}}. When instantiating a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} by reading from a stream or byte array, the {\ttfamily Name} property remains {\ttfamily null}. When saving to a stream, the {\ttfamily Name} property is implicitly set to {\ttfamily null}. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7968b0265bacd1a670497fd87c824cef}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7968b0265bacd1a670497fd87c824cef}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Number\+Of\+Segments\+For\+Most\+Recent\+Save@{Number\+Of\+Segments\+For\+Most\+Recent\+Save}}
\index{Number\+Of\+Segments\+For\+Most\+Recent\+Save@{Number\+Of\+Segments\+For\+Most\+Recent\+Save}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Number\+Of\+Segments\+For\+Most\+Recent\+Save}{NumberOfSegmentsForMostRecentSave}}
{\footnotesize\ttfamily Int32 Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Number\+Of\+Segments\+For\+Most\+Recent\+Save\hspace{0.3cm}{\ttfamily [get]}}



Returns the number of segments used in the most recent \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} operation. 

This is normally zero, unless you have set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}{Max\+Output\+Segment\+Size}} property. If you have set \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}{Max\+Output\+Segment\+Size}}, and then you save a file, after the call to \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} completes, you can read this value to learn the number of segments that were created. 

If you call Save(\char`\"{}\+Archive.\+zip\char`\"{}), and it creates 5 segments, then you will have filesystem files named Archive.\+z01, Archive.\+z02, Archive.\+z03, Archive.\+z04, and Archive.\+zip, and the value of this property will be 5. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4cac13117d40a66892c4b92d2ee2f355}{Max\+Output\+Segment\+Size}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Output\+Used\+Zip64@{Output\+Used\+Zip64}}
\index{Output\+Used\+Zip64@{Output\+Used\+Zip64}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Output\+Used\+Zip64}{OutputUsedZip64}}
{\footnotesize\ttfamily Nullable$<$bool$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Output\+Used\+Zip64\hspace{0.3cm}{\ttfamily [get]}}



Indicates whether the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} operation used Z\+I\+P64 extensions. 

The use of Z\+I\+P64 extensions within an archive is not always necessary, and for interoperability concerns, it may be desired to N\+OT use Z\+I\+P64 if possible. The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Zip\+File.\+Use\+Zip64\+When\+Saving}} property can be set to use Z\+I\+P64 extensions only when necessary. In those cases, Sometimes applications want to know whether a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} actually used Z\+I\+P64 extensions. Applications can query this read-\/only property to learn whether Z\+I\+P64 has been used in a just-\/saved {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

The value is {\ttfamily null} (or {\ttfamily Nothing} in VB) if the archive has not been saved. 

Non-\/null values ({\ttfamily Has\+Value} is true) indicate whether Z\+I\+P64 extensions were used during the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} operation. The Z\+I\+P64 extensions may have been used as required by any particular entry because of its uncompressed or compressed size, or because the archive is larger than 4294967295 bytes, or because there are more than 65534 entries in the archive, or because the {\ttfamily Use\+Zip64\+When\+Saving} property was set to \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a68eec46437c384d8dad18d5464ebc35c}{Zip64\+Option.\+Always}}, or because the {\ttfamily Use\+Zip64\+When\+Saving} property was set to \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a7bfa2d7f3d5b79692fe22a06113406c8}{Zip64\+Option.\+As\+Necessary}} and the output stream was not seekable. The value of this property does not indicate the reason the Z\+I\+P64 extensions were used. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Use\+Zip64\+When\+Saving}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9901125cb78c8e646a6e516669334632}{Requires\+Zip64}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad0e3f7ed7377d0d8d71154d893375fb5}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad0e3f7ed7377d0d8d71154d893375fb5}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Parallel\+Deflate\+Max\+Buffer\+Pairs@{Parallel\+Deflate\+Max\+Buffer\+Pairs}}
\index{Parallel\+Deflate\+Max\+Buffer\+Pairs@{Parallel\+Deflate\+Max\+Buffer\+Pairs}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Parallel\+Deflate\+Max\+Buffer\+Pairs}{ParallelDeflateMaxBufferPairs}}
{\footnotesize\ttfamily int Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Parallel\+Deflate\+Max\+Buffer\+Pairs\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The maximum number of buffer pairs to use when performing parallel compression. 

This property sets an upper limit on the number of memory buffer pairs to create when performing parallel compression. The implementation of the parallel compression stream allocates multiple buffers to facilitate parallel compression. As each buffer fills up, the stream uses \mbox{\hyperlink{}{Thread\+Pool.\+Queue\+User\+Work\+Item()}} to compress those buffers in a background threadpool thread. After a buffer is compressed, it is re-\/ordered and written to the output stream. 

A higher number of buffer pairs enables a higher degree of parallelism, which tends to increase the speed of compression on multi-\/cpu computers. On the other hand, a higher number of buffer pairs also implies a larger memory consumption, more active worker threads, and a higher cpu utilization for any compression. This property enables the application to limit its memory consumption and C\+PU utilization behavior depending on requirements. 

For each compression \char`\"{}task\char`\"{} that occurs in parallel, there are 2 buffers allocated\+: one for input and one for output. This property sets a limit for the number of pairs. The total amount of storage space allocated for buffering will then be (N$\ast$\+S$\ast$2), where N is the number of buffer pairs, S is the size of each buffer (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ae9a8e5c950de0778aafa3e3c28b8ada5}{Buffer\+Size}}). By default, Dot\+Net\+Zip allocates 4 buffer pairs per C\+PU core, so if your machine has 4 cores, and you retain the default buffer size of 128k, then the Parallel\+Deflate\+Output\+Stream will use 4 $\ast$ 4 $\ast$ 2 $\ast$ 128kb of buffer memory in total, or 4mb, in blocks of 128kb. If you then set this property to 8, then the number will be 8 $\ast$ 2 $\ast$ 128kb of buffer memory, or 2mb. 

C\+PU utilization will also go up with additional buffers, because a larger number of buffer pairs allows a larger number of background threads to compress in parallel. If you find that parallel compression is consuming too much memory or C\+PU, you can adjust this value downward. 

The default value is 16. Different values may deliver better or worse results, depending on your priorities and the dynamic performance characteristics of your storage and compute resources. 

This property is not the number of buffer pairs to use; it is an upper limit. An illustration\+: Suppose you have an application that uses the default value of this property (which is 16), and it runs on a machine with 2 C\+PU cores. In that case, Dot\+Net\+Zip will allocate 4 buffer pairs per C\+PU core, for a total of 8 pairs. The upper limit specified by this property has no effect. 

The application can set this value at any time before calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab5cbcfc51b1d21f281ae8d2db8c4ded9}{Parallel\+Deflate\+Threshold}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab5cbcfc51b1d21f281ae8d2db8c4ded9}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab5cbcfc51b1d21f281ae8d2db8c4ded9}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Parallel\+Deflate\+Threshold@{Parallel\+Deflate\+Threshold}}
\index{Parallel\+Deflate\+Threshold@{Parallel\+Deflate\+Threshold}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Parallel\+Deflate\+Threshold}{ParallelDeflateThreshold}}
{\footnotesize\ttfamily long Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Parallel\+Deflate\+Threshold\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The size threshold for an entry, above which a parallel deflate is used. 

Dot\+Net\+Zip will use multiple threads to compress any \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}, if the entry is larger than the given size. Zero means \char`\"{}always
    use parallel deflate\char`\"{}, while -\/1 means \char`\"{}never use parallel
    deflate\char`\"{}. The default value for this property is 512k. Aside from the special values of 0 and 1, the minimum value is 65536. 

If the entry size cannot be known before compression, as with a read-\/forward stream, then Parallel deflate will never be performed, unless the value of this property is zero. 

A parallel deflate operations will speed up the compression of large files, on computers with multiple C\+P\+Us or multiple C\+PU cores. For files above 1mb, on a dual core or dual-\/cpu (2p) machine, the time required to compress the file can be 70\% of the single-\/threaded deflate. For very large files on 4p machines the compression can be done in 30\% of the normal time. The downside is that parallel deflate consumes extra memory during the deflate, and the deflation is not as effective. 

Parallel deflate tends to yield slightly less compression when compared to as single-\/threaded deflate; this is because the original data stream is split into multiple independent buffers, each of which is compressed in parallel. But because they are treated independently, there is no opportunity to share compression dictionaries. For that reason, a deflated stream may be slightly larger when compressed using parallel deflate, as compared to a traditional single-\/threaded deflate. Sometimes the increase over the normal deflate is as much as 5\% of the total compressed size. For larger files it can be as small as 0.\+1\%. 

Multi-\/threaded compression does not give as much an advantage when using Encryption. This is primarily because encryption tends to slow down the entire pipeline. Also, multi-\/threaded compression gives less of an advantage when using lower compression levels, for example \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_a20f6771804996c363f454ad9765cd7dba8811d18b7814723c306a299c49e86701}{Ionic.\+Zlib.\+Compression\+Level.\+Best\+Speed}}. You may have to perform some tests to determine the best approach for your situation. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ad0e3f7ed7377d0d8d71154d893375fb5}{Parallel\+Deflate\+Max\+Buffer\+Pairs}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Password@{Password}}
\index{Password@{Password}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Password}{Password}}
{\footnotesize\ttfamily String Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Password\hspace{0.3cm}{\ttfamily [set]}}



Sets the password to be used on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. 

When writing a zip archive, this password is applied to the entries, not to the zip archive itself. It applies to any {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, using one of the {\ttfamily Add\+File}, {\ttfamily Add\+Directory}, {\ttfamily Add\+Entry}, or {\ttfamily Add\+Item} methods, etc. When reading a zip archive, this property applies to any entry subsequently extracted from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} using one of the Extract methods on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class. 

When writing a zip archive, keep this in mind\+: though the password is set on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} object, according to the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} spec, the \char`\"{}directory\char`\"{} of the archive -\/ in other words the list of entries or files contained in the archive -\/ is not encrypted with the password, or protected in any way. If you set the Password property, the password actually applies to individual entries that are added to the archive, subsequent to the setting of this property. The list of filenames in the archive that is eventually created will appear in clear text, but the contents of the individual files are encrypted. This is how \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} encryption works. 

One simple way around this limitation is to simply double-\/wrap sensitive filenames\+: Store the files in a zip file, and then store that zip file within a second, \char`\"{}outer\char`\"{} zip file. If you apply a password to the outer zip file, then readers will be able to see that the outer zip file contains an inner zip file. But readers will not be able to read the directory or file list of the inner zip file. 

If you set the password on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, and then add a set of files to the archive, then each entry is encrypted with that password. You may also want to change the password between adding different entries. If you set the password, add an entry, then set the password to {\ttfamily null} ({\ttfamily Nothing} in VB), and add another entry, the first entry is encrypted and the second is not. If you call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a931b397196d9fb9a4778a77423d2103c}{Add\+File()}}}, then set the {\ttfamily Password} property, then call {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save}}}, the file added will not be password-\/protected, and no warning will be generated. 

When setting the Password, you may also want to explicitly set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}} property, to specify how to encrypt the entries added to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}. If you set the Password to a non-\/null value and do not set \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, then P\+K\+Zip 2.\+0 (\char`\"{}\+Weak\char`\"{}) encryption is used. This encryption is relatively weak but is very interoperable. If you set the password to a {\ttfamily null} value ({\ttfamily Nothing} in VB), Encryption is reset to None. 

All of the preceding applies to writing zip archives, in other words when you use one of the Save methods. To use this property when reading or an existing \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, do the following\+: set the Password property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, then call one of the Extract() overloads on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}. In this case, the entry is extracted using the {\ttfamily Password} that is specified on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. If you have not set the {\ttfamily Password} property, then the password is {\ttfamily null}, and the entry is extracted with no password. 

If you set the Password property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, then call {\ttfamily Extract()} an entry that has not been encrypted with a password, the password is not used for that entry, and the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} is extracted as normal. In other words, the password is used only if necessary. 

The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} class also has a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a4e1ce23f98c2e3a60a2d47a25a243a82}{Password}} property. It takes precedence over this property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. Typically, you would use the per-\/entry Password when most entries in the zip archive use one password, and a few entries use a different password. If all entries in the zip file use the same password, then it is simpler to just set this property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} itself, whether creating a zip archive or extracting a zip archive. 

This example creates a zip file, using password protection for the entries, and then extracts the entries from the zip file. When creating the zip file, the Readme.\+txt file is not protected with a password, but the other two are password-\/protected as they are saved. During extraction, each file is extracted with the appropriate password. 


\begin{DoxyCode}
\textcolor{comment}{// create a file with encryption}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddFile(\textcolor{stringliteral}{"ReadMe.txt"});
    zip.Password= \textcolor{stringliteral}{"!Secret1"};
    zip.AddFile(\textcolor{stringliteral}{"MapToTheSite-7440-N49th.png"});
    zip.AddFile(\textcolor{stringliteral}{"2008-Regional-Sales-Report.pdf"});
    zip.Save(\textcolor{stringliteral}{"EncryptedArchive.zip"});
\}

\textcolor{comment}{// extract entries that use encryption}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"EncryptedArchive.zip"}))
\{
    zip.Password= \textcolor{stringliteral}{"!Secret1"};
    zip.ExtractAll(\textcolor{stringliteral}{"extractDir"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip.AddFile(\textcolor{stringliteral}{"ReadMe.txt"})
    zip.Password = \textcolor{stringliteral}{"123456!"}
    zip.AddFile(\textcolor{stringliteral}{"MapToTheSite-7440-N49th.png"})
    zip.Password= \textcolor{stringliteral}{"!Secret1"};
    zip.AddFile(\textcolor{stringliteral}{"2008-Regional-Sales-Report.pdf"})
    zip.Save(\textcolor{stringliteral}{"EncryptedArchive.zip"})
End Using


\textcolor{stringliteral}{' extract entries that use encryption}
\textcolor{stringliteral}{Using (zip as ZipFile = ZipFile.Read("EncryptedArchive.zip"))}
\textcolor{stringliteral}{    zip.Password= "!Secret1"}
\textcolor{stringliteral}{    zip.ExtractAll("extractDir")}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Ionic.\+Zip.\+Zip\+File.\+Encryption}}


\end{DoxySeeAlso}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Zip\+File.\+Encryption}}

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a4e1ce23f98c2e3a60a2d47a25a243a82}{Ionic.\+Zip.\+Zip\+Entry.\+Password}}


\end{DoxySeeAlso}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a4e1ce23f98c2e3a60a2d47a25a243a82}{Zip\+Entry.\+Password}}\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Provisional\+Alternate\+Encoding@{Provisional\+Alternate\+Encoding}}
\index{Provisional\+Alternate\+Encoding@{Provisional\+Alternate\+Encoding}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Provisional\+Alternate\+Encoding}{ProvisionalAlternateEncoding}}
{\footnotesize\ttfamily System.\+Text.\+Encoding Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Provisional\+Alternate\+Encoding\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The text encoding to use when writing new entries to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, for those entries that cannot be encoded with the default (I\+B\+M437) encoding; or, the text encoding that was used when reading the entries from the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. 

In its zip specification

, P\+K\+Ware describes two options for encoding filenames and comments\+: using I\+B\+M437 or U\+T\+F-\/8. But, some archiving tools or libraries do not follow the specification, and instead encode characters using the system default code page. For example, Win\+R\+AR when run on a machine in Shanghai may encode filenames with the Big-\/5 Chinese (950) code page. This behavior is contrary to the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} specification, but it occurs anyway. 

When using Dot\+Net\+Zip to write zip archives that will be read by one of these other archivers, set this property to specify the code page to use when encoding the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a78e0c5ee8272a51926eabb9ffc1b38d9}{Zip\+Entry.\+File\+Name}} and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a59ecd22f231ce6c16aec38e12a90bd6a}{Zip\+Entry.\+Comment}} for each {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} in the zip file, for values that cannot be encoded with the default codepage for zip files, I\+B\+M437. This is why this property is \char`\"{}provisional\char`\"{}. In all cases, I\+B\+M437 is used where possible, in other words, where no loss of data would result. It is possible, therefore, to have a given entry with a {\ttfamily Comment} encoded in I\+B\+M437 and a {\ttfamily File\+Name} encoded with the specified \char`\"{}provisional\char`\"{} codepage. 

Be aware that a zip file created after you\textquotesingle{}ve explicitly set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} property to a value other than I\+B\+M437 may not be compliant to the P\+K\+Ware specification, and may not be readable by compliant archivers. On the other hand, many (most?) archivers are non-\/compliant and can read zip files created in arbitrary code pages. The trick is to use or specify the proper codepage when reading the zip. 

When creating a zip archive using this library, it is possible to change the value of \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} between each entry you add, and between adding entries and the call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. Don\textquotesingle{}t do this. It will likely result in a zipfile that is not readable. For best interoperability, either leave \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} alone, or specify it only once, before adding any entries to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. There is one exception to this recommendation, described later. 

When using an arbitrary, non-\/\+U\+T\+F8 code page for encoding, there is no standard way for the creator application -\/ whether Dot\+Net\+Zip, Win\+Zip, Win\+Rar, or something else -\/ to formally specify in the zip file which codepage has been used for the entries. As a result, readers of zip files are not able to inspect the zip file and determine the codepage that was used for the entries contained within it. It is left to the application or user to determine the necessary codepage when reading zip files encoded this way. In other words, if you explicitly specify the codepage when you create the zipfile, you must explicitly specify the same codepage when reading the zipfile. 

The way you specify the code page to use when reading a zip file varies depending on the tool or library you use to read the zip. In Dot\+Net\+Zip, you use a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}} method that accepts an encoding parameter. It isn\textquotesingle{}t possible with Windows Explorer, as far as I know, to specify an explicit codepage to use when reading a zip. If you use an incorrect codepage when reading a zipfile, you will get entries with filenames that are incorrect, and the incorrect filenames may even contain characters that are not legal for use within filenames in Windows. Extracting entries with illegal characters in the filenames will lead to exceptions. It\textquotesingle{}s too bad, but this is just the way things are with code pages in zip files. Caveat Emptor. 

Example\+: Suppose you create a zipfile that contains entries with filenames that have Danish characters. If you use \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} equal to \char`\"{}iso-\/8859-\/1\char`\"{} (cp 28591), the filenames will be correctly encoded in the zip. But, to read that zipfile correctly, you have to specify the same codepage at the time you read it. If try to read that zip file with Windows Explorer or another application that is not flexible with respect to the codepage used to decode filenames in zipfiles, you will get a filename like \char`\"{}\+Inf.\+txt\char`\"{}. 

When using Dot\+Net\+Zip to read a zip archive, and the zip archive uses an arbitrary code page, you must specify the encoding to use before or when the {\ttfamily Zipfile} is R\+E\+AD. This means you must use a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}} method that allows you to specify a System.\+Text.\+Encoding parameter. Setting the Provisional\+Alternate\+Encoding property after your application has read in the zip archive will not affect the entry names of entries that have already been read in. 

And now, the exception to the rule described above. One strategy for specifying the code page for a given zip file is to describe the code page in a human-\/readable form in the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} comment. For example, the comment may read \char`\"{}\+Entries in this archive are encoded in the Big5 code page\char`\"{}. For maximum interoperability, the zip comment in this case should be encoded in the default, I\+B\+M437 code page. In this case, the zip comment is encoded using a different page than the filenames. To do this, Specify {\ttfamily Provisional\+Alternate\+Encoding} to your desired region-\/specific code page, once before adding any entries, and then reset {\ttfamily Provisional\+Alternate\+Encoding} to I\+B\+M437 before setting the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}} property and calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}. 

This example shows how to read a zip file using the Big-\/5 Chinese code page (950), and extract each entry in the zip file. For this code to work as desired, the {\ttfamily Zipfile} must have been created using the big5 code page (C\+P950). This is typical, for example, when using Win\+Rar on a machine with C\+P950 set as the default code page. In that case, the names of entries within the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive will be stored in that code page, and reading the zip archive must be done using that code page. If the application did not use the correct code page in {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}}}, then names of entries within the zip archive would not be correctly retrieved. 
\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipFileName, \mbox{\hyperlink{namespace_system}{System}}.Text.Encoding.GetEncoding(\textcolor{stringliteral}{"big5"})))
\{
    \textcolor{comment}{// retrieve and extract an entry using a name encoded with CP950}
    zip[MyDesiredEntry].Extract(\textcolor{stringliteral}{"unpack"});
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(ZipToExtract, \mbox{\hyperlink{namespace_system}{System}}.Text.Encoding.GetEncoding(\textcolor{stringliteral}{"
      big5"}))
    \textcolor{stringliteral}{' retrieve and extract an entry using a name encoded with CP950}
\textcolor{stringliteral}{    zip(MyDesiredEntry).Extract("unpack")}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a55217486008cf80cba92210c592471f1}{Ionic.\+Zip.\+Zip\+File.\+Default\+Encoding}}


\end{DoxySeeAlso}
Default\+Encoding\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9901125cb78c8e646a6e516669334632}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9901125cb78c8e646a6e516669334632}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Requires\+Zip64@{Requires\+Zip64}}
\index{Requires\+Zip64@{Requires\+Zip64}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Requires\+Zip64}{RequiresZip64}}
{\footnotesize\ttfamily Nullable$<$bool$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Requires\+Zip64\hspace{0.3cm}{\ttfamily [get]}}



Indicates whether the archive requires Z\+I\+P64 extensions. 

This property is {\ttfamily null} (or {\ttfamily Nothing} in VB) if the archive has not been saved, and there are fewer than 65334 {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} items contained in the archive. 

The {\ttfamily Value} is true if any of the following four conditions holds\+: the uncompressed size of any entry is larger than 0x\+F\+F\+F\+F\+F\+F\+FF; the compressed size of any entry is larger than 0x\+F\+F\+F\+F\+F\+F\+FF; the relative offset of any entry within the zip archive is larger than 0x\+F\+F\+F\+F\+F\+F\+FF; or there are more than 65534 entries in the archive. (0x\+F\+F\+F\+F\+F\+F\+FF = 4,294,967,295). The result may not be known until a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} is attempted on the zip archive. The Value of this System.\+Nullable property may be set only A\+F\+T\+ER one of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} methods has been called. 

If none of the four conditions holds, and the archive has been saved, then the {\ttfamily Value} is false. 

A {\ttfamily Value} of false does not indicate that the zip archive, as saved, does not use Z\+I\+P64. It merely indicates that Z\+I\+P64 is not required. An archive may use Z\+I\+P64 even when not required if the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Zip\+File.\+Use\+Zip64\+When\+Saving}} property is set to \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a68eec46437c384d8dad18d5464ebc35c}{Zip64\+Option.\+Always}}, or if the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Zip\+File.\+Use\+Zip64\+When\+Saving}} property is set to \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a7bfa2d7f3d5b79692fe22a06113406c8}{Zip64\+Option.\+As\+Necessary}} and the output stream was not seekable. Use the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}{Output\+Used\+Zip64}} property to determine if the most recent {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} method resulted in an archive that utilized the Z\+I\+P64 extensions. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}{Use\+Zip64\+When\+Saving}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}{Output\+Used\+Zip64}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_abd6bdba1b63a17f284509bbc0fb66637}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Set\+Compression@{Set\+Compression}}
\index{Set\+Compression@{Set\+Compression}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Set\+Compression}{SetCompression}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_ab6b15a72531220e6f98c46b594c9a849}{Set\+Compression\+Callback}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Set\+Compression\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



A callback that allows the application to specify the compression level to use for entries subsequently added to the zip archive. 

With this callback, the Dot\+Net\+Zip library allows the application to determine whether compression will be used, at the time of the {\ttfamily Save}. This may be useful if the application wants to favor speed over size, and wants to defer the decision until the time of {\ttfamily Save}. 

Typically applications set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} or on each {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} to determine the level of compression used. This is done at the time the entry is added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}. Setting the property to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_a20f6771804996c363f454ad9765cd7dba6adf97f83acf6453d4a6a4b1070f3754}{Ionic.\+Zlib.\+Compression\+Level.\+None}}} means no compression will be used. 

This callback allows the application to defer the decision on the {\ttfamily Compression\+Level} to use, until the time of the call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}}. The callback is invoked once per {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}}, at the time the data for the entry is being written out as part of a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} operation. The application can use whatever criteria it likes in determining the level to return. For example, an application may wish that no .mp3 files should be compressed, because they are already compressed and the extra compression is not worth the C\+PU time incurred, and so can return {\ttfamily None} for all .mp3 entries. 

The library determines whether compression will be attempted for an entry this way\+: If the entry is a zero length file, or a directory, no compression is used. Otherwise, if this callback is set, it is invoked and the {\ttfamily Compression\+Level} is set to the return value. If this callback has not been set, then the previously set value for {\ttfamily Compression\+Level} is used. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4572fef33a794fcbb717f6959b97d6f5}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4572fef33a794fcbb717f6959b97d6f5}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Sort\+Entries\+Before\+Saving@{Sort\+Entries\+Before\+Saving}}
\index{Sort\+Entries\+Before\+Saving@{Sort\+Entries\+Before\+Saving}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Sort\+Entries\+Before\+Saving}{SortEntriesBeforeSaving}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Sort\+Entries\+Before\+Saving\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Whether to sort the Zip\+Entries before saving the file. 

The default is false. If you have a large number of zip entries, the sort alone can consume significant time. 


\begin{DoxyCode}
\textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
    zip.AddFiles(filesToAdd);
    zip.SortEntriesBeforeSaving = \textcolor{keyword}{true};
    zip.Save(name);
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
    zip.AddFiles(filesToAdd)
    zip.SortEntriesBeforeSaving = True
    zip.Save(name)
End Using
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Status\+Message\+Text\+Writer@{Status\+Message\+Text\+Writer}}
\index{Status\+Message\+Text\+Writer@{Status\+Message\+Text\+Writer}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Status\+Message\+Text\+Writer}{StatusMessageTextWriter}}
{\footnotesize\ttfamily Text\+Writer Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Status\+Message\+Text\+Writer\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Gets or sets the {\ttfamily Text\+Writer} to which status messages are delivered for the instance. 

If the Text\+Writer is set to a non-\/null value, then verbose output is sent to the {\ttfamily Text\+Writer} during {\ttfamily Add}{\ttfamily , Read}{\ttfamily , Save} and {\ttfamily Extract} operations. Typically, console applications might use {\ttfamily Console.\+Out} and graphical or headless applications might use a {\ttfamily System.\+I\+O.\+String\+Writer}. The output of this is suitable for viewing by humans. 

In this example, a console application instantiates a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, then sets the {\ttfamily Status\+Message\+Text\+Writer} to {\ttfamily Console.\+Out}. At that point, all verbose status messages for that {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} are sent to the console. 


\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip= \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(FilePath))
\{
  zip.StatusMessageTextWriter= \mbox{\hyperlink{namespace_system}{System}}.Console.Out;
  \textcolor{comment}{// messages are sent to the console during extraction}
  zip.ExtractAll();
\}
\end{DoxyCode}



\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(FilePath)
  zip.StatusMessageTextWriter= \mbox{\hyperlink{namespace_system}{System}}.Console.Out
  \textcolor{stringliteral}{'Status Messages will be sent to the console during extraction}
\textcolor{stringliteral}{  zip.ExtractAll()}
\textcolor{stringliteral}{End Using}
\end{DoxyCode}


In this example, a Windows Forms application instantiates a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, then sets the {\ttfamily Status\+Message\+Text\+Writer} to a {\ttfamily String\+Writer}. At that point, all verbose status messages for that {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} are sent to the {\ttfamily String\+Writer}. 


\begin{DoxyCode}
var sw = \textcolor{keyword}{new} \mbox{\hyperlink{namespace_system}{System}}.IO.StringWriter();
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip= \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(FilePath))
\{
  zip.StatusMessageTextWriter= sw;
  zip.ExtractAll();
\}
Console.WriteLine(\textcolor{stringliteral}{"\{0\}"}, sw.ToString());
\end{DoxyCode}



\begin{DoxyCode}
Dim sw as New \mbox{\hyperlink{namespace_system}{System}}.IO.StringWriter
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(FilePath)
  zip.StatusMessageTextWriter= sw
  zip.ExtractAll()
End Using
\textcolor{stringliteral}{'Status Messages are now available in sw}
\end{DoxyCode}
 \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a891511a2bde8493e29fb7c473f4e6eee}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a891511a2bde8493e29fb7c473f4e6eee}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Strategy@{Strategy}}
\index{Strategy@{Strategy}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Strategy}{Strategy}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_abde5c10a1e2ee453e1e8e22e79a39a3b}{Ionic.\+Zlib.\+Compression\+Strategy}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Strategy\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The compression strategy to use for all entries. 

Set the Strategy used by the Z\+L\+I\+B-\/compatible compressor, when compressing entries using the D\+E\+F\+L\+A\+TE method. Different compression strategies work better on different sorts of data. The strategy parameter can affect the compression ratio and the speed of compression but not the correctness of the compresssion. For more information see \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zlib_abde5c10a1e2ee453e1e8e22e79a39a3b}{Ionic.\+Zlib.\+Compression\+Strategy}}. \mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5b51af53eca5a8c0aa52d950f04c4add}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a5b51af53eca5a8c0aa52d950f04c4add}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Temp\+File\+Folder@{Temp\+File\+Folder}}
\index{Temp\+File\+Folder@{Temp\+File\+Folder}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Temp\+File\+Folder}{TempFileFolder}}
{\footnotesize\ttfamily String Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Temp\+File\+Folder\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Gets or sets the name for the folder to store the temporary file this library writes when saving a zip archive. 

This library will create a temporary file when saving a \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive to a file. This file is written when calling one of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} methods that does not save to a stream, or one of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{Save\+Self\+Extractor()}}} methods. 

By default, the library will create the temporary file in the directory specified for the file itself, via the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8a930e5cdb1e9e0bcd1e3105b7aed508}{Name}} property or via the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9462814d3ebaee71081aea1fc5de1ffc}{Zip\+File.\+Save(\+String)}} method. 

Setting this property allows applications to override this default behavior, so that the library will create the temporary file in the specified folder. For example, to have the library create the temporary file in the current working directory, regardless where the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} is saved, specfy \char`\"{}.\char`\"{}. To revert to the default behavior, set this property to {\ttfamily null} ({\ttfamily Nothing} in VB). 

When setting the property to a non-\/null value, the folder specified must exist; if it does not an exception is thrown. The application should have write and delete permissions on the folder. The permissions are not explicitly checked ahead of time; if the application does not have the appropriate rights, an exception will be thrown at the time {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} is called. 

There is no temporary file created when reading a zip archive. When saving to a Stream, there is no temporary file created. For example, if the application is an A\+S\+P.\+N\+ET application and calls {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} specifying the {\ttfamily Response.\+Output\+Stream} as the output stream, there is no temporary file created. 


\begin{DoxyExceptions}{Exceptions}
{\em System.\+I\+O.\+File\+Not\+Found\+Exception} & Thrown when setting the property if the directory does not exist. \\
\hline
\end{DoxyExceptions}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a6c57057729f935413dd8fc2945dfb378}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a6c57057729f935413dd8fc2945dfb378}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!this\mbox{[}int ix\mbox{]}@{this[int ix]}}
\index{this\mbox{[}int ix\mbox{]}@{this[int ix]}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{this[int ix]}{this[int ix]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+this\mbox{[}int ix\mbox{]}\hspace{0.3cm}{\ttfamily [get]}}



This is an integer indexer into the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. 

This property is read-\/only. 

Internally, the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} instances that belong to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} are stored in a Dictionary. When you use this indexer the first time, it creates a read-\/only {\ttfamily List$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}$>$} from the Dictionary.\+Values Collection. If at any time you modify the set of entries in the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, either by adding an entry, removing an entry, or renaming an entry, a new List will be created, and the numeric indexes for the remaining entries may be different. 

This means you cannot rename any \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} from inside an enumeration of the zip file. 


\begin{DoxyParams}{Parameters}
{\em ix} & The index value. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} within the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive at the specified index. If the entry does not exist in the archive, this indexer throws. 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9d0f9d576a79c40859970894bcb171f4}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9d0f9d576a79c40859970894bcb171f4}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!this\mbox{[}\+String file\+Name\mbox{]}@{this[String file\+Name]}}
\index{this\mbox{[}\+String file\+Name\mbox{]}@{this[String file\+Name]}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{this[String file\+Name]}{this[String fileName]}}
{\footnotesize\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+this\mbox{[}String file\+Name\mbox{]}\hspace{0.3cm}{\ttfamily [get]}}



This is a name-\/based indexer into the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive. 

This property is read-\/only. 

The \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeb25467e1a84cabe712c5a30603d3bf6}{Case\+Sensitive\+Retrieval}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} determines whether retrieval via this indexer is done via case-\/sensitive comparisons. By default, retrieval is not case sensitive. This makes sense on Windows, in which filesystems are not case sensitive. 

Regardless of case-\/sensitivity, it is not always the case that {\ttfamily this\mbox{[}value\mbox{]}.File\+Name == value}. In other words, the {\ttfamily File\+Name} property of the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} retrieved with this indexer, may or may not be equal to the index value. 

This is because Dot\+Net\+Zip performs a normalization of filenames passed to this indexer, before attempting to retrieve the item. That normalization includes\+: removal of a volume letter and colon, swapping backward slashes for forward slashes. So, {\ttfamily zip\mbox{[}\char`\"{}dir1\textbackslash{}\textbackslash{}entry1.\+txt\char`\"{}\mbox{]}.File\+Name == \char`\"{}dir1/entry.\+txt\char`\"{}}. 

Directory entries in the zip file may be retrieved via this indexer only with names that have a trailing slash. Dot\+Net\+Zip automatically appends a trailing slash to the names of any directory entries added to a zip. 

This example extracts only the entries in a zip file that are .txt files. 
\begin{DoxyCode}
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"PackedDocuments.zip"}))
\{
  \textcolor{keywordflow}{foreach} (\textcolor{keywordtype}{string} s1 \textcolor{keywordflow}{in} zip.EntryFilenames)
  \{
    \textcolor{keywordflow}{if} (s1.EndsWith(\textcolor{stringliteral}{".txt"}))
      zip[s1].Extract(\textcolor{stringliteral}{"textfiles"});
  \}
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(\textcolor{stringliteral}{"PackedDocuments.zip"})
    Dim s1 As String
    For Each s1 In zip.EntryFilenames
        If s1.EndsWith(\textcolor{stringliteral}{".txt"}) Then
            zip(s1).Extract(\textcolor{stringliteral}{"textfiles"})
        End If
    Next
End Using
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
Ionic.\+Zip.\+Zip\+File.\+Remove\+Entry(string)


\end{DoxySeeAlso}



\begin{DoxyExceptions}{Exceptions}
{\em System.\+Argument\+Exception} & Thrown if the caller attempts to assign a non-\/null value to the indexer. \\
\hline
\end{DoxyExceptions}



\begin{DoxyParams}{Parameters}
{\em file\+Name} & The name of the file, including any directory path, to retrieve from the zip. The filename match is not case-\/sensitive by default; you can use the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeb25467e1a84cabe712c5a30603d3bf6}{Case\+Sensitive\+Retrieval}} property to change this behavior. The pathname can use forward-\/slashes or backward slashes. \\
\hline
\end{DoxyParams}


\begin{DoxyReturn}{Returns}
The {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} within the \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} archive, given by the specified filename. If the named entry does not exist in the archive, this indexer returns {\ttfamily null} ({\ttfamily Nothing} in VB). 
\end{DoxyReturn}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa55d8b8c5ff20f83892d7d4c694c4b6a}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa55d8b8c5ff20f83892d7d4c694c4b6a}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Use\+Unicode\+As\+Necessary@{Use\+Unicode\+As\+Necessary}}
\index{Use\+Unicode\+As\+Necessary@{Use\+Unicode\+As\+Necessary}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Use\+Unicode\+As\+Necessary}{UseUnicodeAsNecessary}}
{\footnotesize\ttfamily bool Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Use\+Unicode\+As\+Necessary\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Indicates whether to encode entry filenames and entry comments using Unicode (U\+T\+F-\/8). 

The P\+K\+Ware zip specification

provides for encoding file names and file comments in either the I\+B\+M437 code page, or in U\+T\+F-\/8. This flag selects the encoding according to that specification. By default, this flag is false, and filenames and comments are encoded into the zip file in the I\+B\+M437 codepage. Setting this flag to true will specify that filenames and comments that cannot be encoded with I\+B\+M437 will be encoded with U\+T\+F-\/8. 

\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} files created with strict adherence to the P\+K\+Ware specification with respect to U\+T\+F-\/8 encoding can contain entries with filenames containing any combination of Unicode characters, including the full range of characters from Chinese, Latin, Hebrew, Greek, Cyrillic, and many other alphabets. However, because at this time, the U\+T\+F-\/8 portion of the P\+K\+Ware specification is not broadly supported by other zip libraries and utilities, such zip files may not be readable by your favorite zip tool or archiver. In other words, interoperability will decrease if you set this flag to true. 

In particular, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip}{Zip}} files created with strict adherence to the P\+K\+Ware specification with respect to U\+T\+F-\/8 encoding will not work well with Explorer in Windows XP or Windows Vista, because Windows compressed folders, as far as I know, do not support U\+T\+F-\/8 in zip files. Vista can read the zip files, but shows the filenames incorrectly. Unpacking from Windows Vista Explorer will result in filenames that have rubbish characters in place of the high-\/order U\+T\+F-\/8 bytes. 

Also, zip files that use U\+T\+F-\/8 encoding will not work well with Java applications that use the java.\+util.\+zip classes, as of v5.\+0 of the Java runtime. The Java runtime does not correctly implement the P\+K\+Ware specification in this regard. 

As a result, we have the unfortunate situation that \char`\"{}correct\char`\"{} behavior by the Dot\+Net\+Zip library with regard to Unicode encoding of filenames during zip creation will result in zip files that are readable by strictly compliant and current tools (for example the most recent release of the commercial Win\+Zip tool); but these zip files will not be readable by various other tools or libraries, including Windows Explorer. 

The Dot\+Net\+Zip library can read and write zip files with U\+T\+F8-\/encoded entries, according to the P\+Kware spec. If you use Dot\+Net\+Zip for both creating and reading the zip file, and you use U\+T\+F-\/8, there will be no loss of information in the filenames. For example, using a self-\/extractor created by this library will allow you to unpack files correctly with no loss of information in the filenames. 

If you do not set this flag, it will remain false. If this flag is false, your {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} will encode all filenames and comments using the I\+B\+M437 codepage. This can cause \char`\"{}loss of information\char`\"{} on some filenames, but the resulting zipfile will be more interoperable with other utilities. As an example of the loss of information, diacritics can be lost. The o-\/tilde character will be down-\/coded to plain o. The c with a cedilla (Unicode 0x\+E7) used in Portugese will be downcoded to a c. Likewise, the O-\/stroke character (Unicode 248), used in Danish and Norwegian, will be down-\/coded to plain o. Chinese characters cannot be represented in codepage I\+B\+M437; when using the default encoding, Chinese characters in filenames will be represented as ?. These are all examples of \char`\"{}information loss\char`\"{}. 

The loss of information associated to the use of the I\+B\+M437 encoding is inconvenient, and can also lead to runtime errors. For example, using I\+B\+M437, any sequence of 4 Chinese characters will be encoded as ????. If your application creates a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, then adds two files, each with names of four Chinese characters each, this will result in a duplicate filename exception. In the case where you add a single file with a name containing four Chinese characters, calling Extract() on the entry that has question marks in the filename will result in an exception, because the question mark is not legal for use within filenames on Windows. These are just a few examples of the problems associated to loss of information. 

This flag is independent of the encoding of the content within the entries in the zip file. Think of the zip file as a container -\/ it supports an encoding. Within the container are other \char`\"{}containers\char`\"{} -\/ the file entries themselves. The encoding within those entries is independent of the encoding of the zip archive container for those entries. 

Rather than specify the encoding in a binary fashion using this flag, an application can specify an arbitrary encoding via the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}} property. Setting the encoding explicitly when creating zip archives will result in non-\/compliant zip files that, curiously, are fairly interoperable. The challenge is, the P\+K\+Ware specification does not provide for a way to specify that an entry in a zip archive uses a code page that is neither I\+B\+M437 nor U\+T\+F-\/8. Therefore if you set the encoding explicitly when creating a zip archive, you must take care upon reading the zip archive to use the same code page. If you get it wrong, the behavior is undefined and may result in incorrect filenames, exceptions, stomach upset, hair loss, and acne. 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aece3d00ca721d3d06020ecc44442ea1e}{Provisional\+Alternate\+Encoding}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aa6813ece810ffc34b633da96143383e6}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Use\+Zip64\+When\+Saving@{Use\+Zip64\+When\+Saving}}
\index{Use\+Zip64\+When\+Saving@{Use\+Zip64\+When\+Saving}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Use\+Zip64\+When\+Saving}{UseZip64WhenSaving}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64\+Option}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Use\+Zip64\+When\+Saving\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



Specify whether to use Z\+I\+P64 extensions when saving a zip archive. 

When creating a zip file, the default value for the property is \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a6e7b34fa59e1bd229b207892956dc41c}{Zip64\+Option.\+Never}}. \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69a7bfa2d7f3d5b79692fe22a06113406c8}{Zip64\+Option.\+As\+Necessary}} is safest, in the sense that you will not get an Exception if a pre-\/\+Z\+I\+P64 limit is exceeded. 

You may set the property at any time before calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}. 

When reading a zip file via the {\ttfamily Zipfile.\+Read()} method, Dot\+Net\+Zip will properly read Z\+I\+P64-\/endowed zip archives, regardless of the value of this property. Dot\+Net\+Zip will always read Z\+I\+P64 archives. This property governs only whether Dot\+Net\+Zip will write them. Therefore, when updating archives, be careful about setting this property after reading an archive that may use Z\+I\+P64 extensions. 

An interesting question is, if you have set this property to {\ttfamily As\+Necessary}, and then successfully saved, does the resulting archive use Z\+I\+P64 extensions or not? To learn this, check the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aab938703416a332f86cfca6344bb00d2}{Output\+Used\+Zip64}} property, after calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. 

Have you thought about donating

? 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9901125cb78c8e646a6e516669334632}{Requires\+Zip64}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+Error\+Action@{Zip\+Error\+Action}}
\index{Zip\+Error\+Action@{Zip\+Error\+Action}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+Error\+Action}{ZipErrorAction}}
{\footnotesize\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593}{Zip\+Error\+Action}} Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+Error\+Action\hspace{0.3cm}{\ttfamily [get]}, {\ttfamily [set]}}



The action the library should take when an error is encountered while opening or reading files as they are saved into a zip archive. 

Errors can occur as a file is being saved to the zip archive. For example, the File.\+Open may fail, or a File.\+Read may fail, because of lock conflicts or other reasons. 

The first problem might occur after having called \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory()}} on a directory that contains a Clipper .dbf file; the file is locked by Clipper and cannot be opened for read by another process. An example of the second problem might occur when trying to zip a .pst file that is in use by Microsoft Outlook. Outlook locks a range on the file, which allows other processes to open the file, but not read it in its entirety. 

This property tells Dot\+Net\+Zip what you would like to do in the case of these errors. The primary options are\+: {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0a8ce61dd2505effd96f937fa743b6491f}{Zip\+Error\+Action.\+Throw}}} to throw an exception (this is the default behavior if you don\textquotesingle{}t set this property); {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a72ef2b9b6965d078e3c7f95487a82d1c}{Zip\+Error\+Action.\+Skip}}} to Skip the file for which there was an error and continue saving; {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a6327b4e59f58137083214a1fec358855}{Zip\+Error\+Action.\+Retry}}} to Retry the entry that caused the problem; or {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a438494fa2a47a746a5f0660862a5bf68}{Zip\+Error\+Action.\+Invoke\+Error\+Event}}} to invoke an event handler. 

This property is implicitly set to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a438494fa2a47a746a5f0660862a5bf68}{Zip\+Error\+Action.\+Invoke\+Error\+Event}}} if you add a handler to the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9c72461567386905e4e52ccb312e4812}{Zip\+Error}} event. If you set this property to something other than {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a438494fa2a47a746a5f0660862a5bf68}{Zip\+Error\+Action.\+Invoke\+Error\+Event}}}, then the {\ttfamily Zip\+Error} event is implicitly cleared. What it means is you can set one or the other (or neither), depending on what you want, but you never need to set both. 

As with some other properties on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} class, like \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a32b5a69438b625f81303940ec70f9c39}{Password}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aeaa88018eaea63cd09f9e05a853c51f8}{Encryption}}, and \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_afd693e850f2336df20158ae8a92f040c}{Compression\+Level}}, setting this property on a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance will cause the specified {\ttfamily Zip\+Error\+Action} to be used on all \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items that are subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. If you set this property after you have added items to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, but before you have called {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, those items will not use the specified error handling action. 

If you want to handle any errors that occur with any entry in the zip file in the same way, then set this property once, before adding any entries to the zip archive. 

If you set this property to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a72ef2b9b6965d078e3c7f95487a82d1c}{Zip\+Error\+Action.\+Skip}}} and you\textquotesingle{}d like to learn which files may have been skipped after a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, you can set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}{Status\+Message\+Text\+Writer}} on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} before calling {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. A message will be emitted into that writer for each skipped file, if any. 

This example shows how to tell Dot\+Net\+Zip to skip any files for which an error is generated during the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}. 
\begin{DoxyCode}
Public Sub SaveZipFile()
    Dim SourceFolder As String = "fodder"
    Dim DestFile As String =  "eHandler.zip"
    Dim sw as New StringWriter
    Using zipArchive As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        ' Tell DotNetZip to skip any files for which it encounters an error
        zipArchive.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{ZipErrorAction}} = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{ZipErrorAction}}.
      \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a72ef2b9b6965d078e3c7f95487a82d1c}{Skip}}
        zipArchive.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a14a4633b584573a738c560b51a7ef70e}{StatusMessageTextWriter}} = sw
        zipArchive.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{AddDirectory}}(SourceFolder)
        zipArchive.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(DestFile)
    End Using
    ' examine sw here to see any messages
End Sub
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a55a679298f00c5eef672e947c6293304}{Ionic.\+Zip.\+Zip\+Entry.\+Zip\+Error\+Action}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9c72461567386905e4e52ccb312e4812}{Ionic.\+Zip.\+Zip\+File.\+Zip\+Error}}


\end{DoxySeeAlso}


\subsection{Event Documentation}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Add\+Progress@{Add\+Progress}}
\index{Add\+Progress@{Add\+Progress}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Add\+Progress}{AddProgress}}
{\footnotesize\ttfamily Event\+Handler$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_add_progress_event_args}{Add\+Progress\+Event\+Args}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Add\+Progress}



An event handler invoked before, during, and after Adding entries to a zip archive. 

Adding a large number of entries to a zip file can take a long time. For example, when calling \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{Add\+Directory(string)}} on a directory that contains 50,000 files, it could take 3 minutes or so. This event handler allws an application to track the progress of the Add operation, and to optionally cancel a lengthy Add operation. 


\begin{DoxyCode}
\textcolor{keywordtype}{int} \_numEntriesToAdd= 0;
\textcolor{keywordtype}{int} \_numEntriesAdded= 0;
\textcolor{keywordtype}{void} AddProgressHandler(\textcolor{keywordtype}{object} sender, AddProgressEventArgs e)
\{
    \textcolor{keywordflow}{switch} (e.EventType)
    \{
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_Started:
            Console.WriteLine(\textcolor{stringliteral}{"Adding files to the zip..."});
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_AfterAddEntry:
            \_numEntriesAdded++;
            Console.WriteLine(String.Format(\textcolor{stringliteral}{"Adding file \{0\}/\{1\} :: \{2\}"},
                                     \_numEntriesAdded, \_numEntriesToAdd, e.CurrentEntry.FileName));
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_Completed:
            Console.WriteLine(\textcolor{stringliteral}{"Added all files"});
            \textcolor{keywordflow}{break};
    \}
\}

\textcolor{keywordtype}{void} CreateTheZip()
\{
    \textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
    \{
        zip.AddProgress += AddProgressHandler;
        zip.AddDirectory(\mbox{\hyperlink{namespace_system}{System}}.IO.Path.GetFileName(DirToZip));
        zip.Save(ZipFileToCreate);
    \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Private Sub AddProgressHandler(ByVal sender As Object, ByVal e As AddProgressEventArgs)
    Select Case e.EventType
        Case \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_Started
            Console.WriteLine(\textcolor{stringliteral}{"Adding files to the zip..."})
            Exit Select
        Case \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_AfterAddEntry
            Console.WriteLine(String.Format(\textcolor{stringliteral}{"Adding file \{0\}"}, e.CurrentEntry.FileName))
            Exit Select
        Case \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Adding\_Completed
            Console.WriteLine(\textcolor{stringliteral}{"Added all files"})
            Exit Select
    End Select
End Sub

Sub CreateTheZip()
    Using zip as \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        AddHandler zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}{AddProgress}}, AddressOf AddProgressHandler
        zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a10260d49cbce321fee3cee6db1f2425e}{AddDirectory}}(\mbox{\hyperlink{namespace_system}{System}}.IO.\mbox{\hyperlink{namespace_path}{Path}}.GetFileName(DirToZip))
        zip.\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save}}(ZipFileToCreate);
    End Using
End Sub
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{Ionic.\+Zip.\+Zip\+File.\+Save\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}{Ionic.\+Zip.\+Zip\+File.\+Read\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{Ionic.\+Zip.\+Zip\+File.\+Extract\+Progress}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Extract\+Progress@{Extract\+Progress}}
\index{Extract\+Progress@{Extract\+Progress}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Extract\+Progress}{ExtractProgress}}
{\footnotesize\ttfamily Event\+Handler$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_extract_progress_event_args}{Extract\+Progress\+Event\+Args}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Extract\+Progress}



An event handler invoked before, during, and after extraction of entries in the zip archive. 

Depending on the particular event, different properties on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_extract_progress_event_args}{Extract\+Progress\+Event\+Args}} parameter are set. The following table summarizes the available Event\+Types and the conditions under which this event handler is invoked with a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_extract_progress_event_args}{Extract\+Progress\+Event\+Args}}} with the given Event\+Type. 

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endhead
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa36adf3f25d454b09928980646e2459d6}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+Before\+Extract\+All}} &Set when \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acf65879aa66b0f58c5af340264b54374}{Extract\+All()}} begins. The Archive\+Name, Overwrite, and Extract\+Location properties are meaningful. 

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa89f4cb8811e15be571ff87cfd6687158}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+After\+Extract\+All}} &Set when \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_acf65879aa66b0f58c5af340264b54374}{Extract\+All()}} has completed. The Archive\+Name, Overwrite, and Extract\+Location properties are meaningful.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841faba311c17b20ee9533ccb290eb7d73f47}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+Before\+Extract\+Entry}} &Set when an Extract() on an entry in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} has begun. Properties that are meaningful\+: Archive\+Name, Entries\+Total, Current\+Entry, Overwrite, Extract\+Location, Entries\+Extracted.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa9800ef70dbd24e2445fdcd260a1487b6}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+After\+Extract\+Entry}} &Set when an Extract() on an entry in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}} has completed. Properties that are meaningful\+: Archive\+Name, Entries\+Total, Current\+Entry, Overwrite, Extract\+Location, Entries\+Extracted.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fab1d6fef4a55c43c15713a126b8471092}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+Entry\+Bytes\+Written}} &Set within a call to Extract() on an entry in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, as data is extracted for the entry. Properties that are meaningful\+: Archive\+Name, Current\+Entry, Bytes\+Transferred, Total\+Bytes\+To\+Transfer.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841faf76e96e54af22ba88a1e180a9c935f05}{Zip\+Progress\+Event\+Type.\+Extracting\+\_\+\+Extract\+Entry\+Would\+Overwrite}} &Set within a call to Extract() on an entry in the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}, when the extraction would overwrite an existing file. This event type is used only when {\ttfamily Extract\+Existing\+File\+Action} on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} or {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} is set to {\ttfamily Invoke\+Extract\+Progress\+Event}.  

\\\cline{1-2}
\end{longtabu}



\begin{DoxyCode}
\textcolor{keyword}{private} \textcolor{keyword}{static} \textcolor{keywordtype}{bool} justHadByteUpdate = \textcolor{keyword}{false};
\textcolor{keyword}{public} \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{ExtractProgress}}(\textcolor{keywordtype}{object} sender, ExtractProgressEventArgs e)
\{
  \textcolor{keywordflow}{if}(e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Extracting\_EntryBytesWritten)
  \{
    \textcolor{keywordflow}{if} (justHadByteUpdate)
      Console.SetCursorPosition(0, Console.CursorTop);

    Console.Write(\textcolor{stringliteral}{"   \{0\}/\{1\} (\{2:N0\}%)"}, e.BytesTransferred, e.TotalBytesToTransfer,
                  e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
    justHadByteUpdate = \textcolor{keyword}{true};
  \}
  \textcolor{keywordflow}{else} \textcolor{keywordflow}{if}(e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Extracting\_BeforeExtractEntry)
  \{
    \textcolor{keywordflow}{if} (justHadByteUpdate)
      Console.WriteLine();
    Console.WriteLine(\textcolor{stringliteral}{"Extracting: \{0\}"}, e.CurrentEntry.FileName);
    justHadByteUpdate= \textcolor{keyword}{false};
  \}
\}

\textcolor{keyword}{public} \textcolor{keyword}{static} ExtractZip(\textcolor{keywordtype}{string} zipToExtract, \textcolor{keywordtype}{string} directory)
\{
  \textcolor{keywordtype}{string} TargetDirectory= \textcolor{stringliteral}{"extract"};
  \textcolor{keyword}{using} (var zip = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}.Read(zipToExtract)) \{
    zip.ExtractProgress += \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{ExtractProgress}};
    \textcolor{keywordflow}{foreach} (var e \textcolor{keywordflow}{in} zip1)
    \{
      e.Extract(TargetDirectory, \textcolor{keyword}{true});
    \}
  \}
\}
\end{DoxyCode}
 
\begin{DoxyCode}
Public Shared Sub Main(ByVal args As String())
    Dim ZipToUnpack As String = "C1P3SML.zip"
    Dim TargetDir As String = "ExtractTest\_Extract"
    Console.WriteLine("Extracting file \{0\} to \{1\}\textcolor{stringliteral}{", ZipToUnpack, TargetDir)}
\textcolor{stringliteral}{    Using zip1 As ZipFile = ZipFile.Read(ZipToUnpack)}
\textcolor{stringliteral}{        AddHandler zip1.ExtractProgress, AddressOf MyExtractProgress}
\textcolor{stringliteral}{        Dim e As ZipEntry}
\textcolor{stringliteral}{        For Each e In zip1}
\textcolor{stringliteral}{            e.Extract(TargetDir, True)}
\textcolor{stringliteral}{        Next}
\textcolor{stringliteral}{    End Using}
\textcolor{stringliteral}{End Sub}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{Private Shared justHadByteUpdate As Boolean = False}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{Public Shared Sub MyExtractProgress(ByVal sender As Object, ByVal e As ExtractProgressEventArgs)}
\textcolor{stringliteral}{    If (e.EventType = ZipProgressEventType.Extracting\_EntryBytesWritten) Then}
\textcolor{stringliteral}{        If ExtractTest.justHadByteUpdate Then}
\textcolor{stringliteral}{            Console.SetCursorPosition(0, Console.CursorTop)}
\textcolor{stringliteral}{        End If}
\textcolor{stringliteral}{        Console.Write("}   \{0\}/\{1\} (\{2:N0\}%)\textcolor{stringliteral}{", e.BytesTransferred, e.TotalBytesToTransfer,
       (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))}
\textcolor{stringliteral}{        ExtractTest.justHadByteUpdate = True}
\textcolor{stringliteral}{    ElseIf (e.EventType = ZipProgressEventType.Extracting\_BeforeExtractEntry) Then}
\textcolor{stringliteral}{        If ExtractTest.justHadByteUpdate Then}
\textcolor{stringliteral}{            Console.WriteLine}
\textcolor{stringliteral}{        End If}
\textcolor{stringliteral}{        Console.WriteLine("}Extracting: \{0\}\textcolor{stringliteral}{", e.CurrentEntry.FileName)}
\textcolor{stringliteral}{        ExtractTest.justHadByteUpdate = False}
\textcolor{stringliteral}{    End If}
\textcolor{stringliteral}{End Sub}
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{Ionic.\+Zip.\+Zip\+File.\+Save\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}{Ionic.\+Zip.\+Zip\+File.\+Read\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}{Ionic.\+Zip.\+Zip\+File.\+Add\+Progress}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Read\+Progress@{Read\+Progress}}
\index{Read\+Progress@{Read\+Progress}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Read\+Progress}{ReadProgress}}
{\footnotesize\ttfamily Event\+Handler$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_progress_event_args}{Read\+Progress\+Event\+Args}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Read\+Progress}



An event handler invoked before, during, and after the reading of a zip archive. 

Depending on the particular event being signaled, different properties on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_progress_event_args}{Read\+Progress\+Event\+Args}} parameter are set. The following table summarizes the available Event\+Types and the conditions under which this event handler is invoked with a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_read_progress_event_args}{Read\+Progress\+Event\+Args}}} with the given Event\+Type. 

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endhead
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fabc902821c623f35074e9fa76d571d6c9}{Zip\+Progress\+Event\+Type.\+Reading\+\_\+\+Started}} &Fired just as \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}} begins. Meaningful properties\+: Archive\+Name.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa1d3f7ae2eca18fce8cc7ec14bd068a58}{Zip\+Progress\+Event\+Type.\+Reading\+\_\+\+Completed}} &Fired when \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a7b5b9f3c89b0bb19938e5f5b101c8f30}{Zip\+File.\+Read()}} has completed. Meaningful properties\+: Archive\+Name.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fac21d747b48ff4e5a157acddc466a3b78}{Zip\+Progress\+Event\+Type.\+Reading\+\_\+\+Archive\+Bytes\+Read}} &Fired while reading, updates the number of bytes read for the entire archive. Meaningful properties\+: Archive\+Name, Current\+Entry, Bytes\+Transferred, Total\+Bytes\+To\+Transfer.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa7eebe2e9801f788320609bcf3c864c29}{Zip\+Progress\+Event\+Type.\+Reading\+\_\+\+Before\+Read\+Entry}} &Indicates an entry is about to be read from the archive. Meaningful properties\+: Archive\+Name, Entries\+Total.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa31f4741b407f9836d3e5c7d7a631f3ce}{Zip\+Progress\+Event\+Type.\+Reading\+\_\+\+After\+Read\+Entry}} &Indicates an entry has just been read from the archive. Meaningful properties\+: Archive\+Name, Entries\+Total, Current\+Entry.  

\\\cline{1-2}
\end{longtabu}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{Ionic.\+Zip.\+Zip\+File.\+Save\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}{Ionic.\+Zip.\+Zip\+File.\+Add\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{Ionic.\+Zip.\+Zip\+File.\+Extract\+Progress}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Save\+Progress@{Save\+Progress}}
\index{Save\+Progress@{Save\+Progress}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Save\+Progress}{SaveProgress}}
{\footnotesize\ttfamily Event\+Handler$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_save_progress_event_args}{Save\+Progress\+Event\+Args}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Save\+Progress}



An event handler invoked when a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} starts, before and after each entry has been written to the archive, when a \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}} completes, and during other Save events. 

Depending on the particular event, different properties on the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_save_progress_event_args}{Save\+Progress\+Event\+Args}} parameter are set. The following table summarizes the available Event\+Types and the conditions under which this event handler is invoked with a {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_save_progress_event_args}{Save\+Progress\+Event\+Args}}} with the given Event\+Type. 

\tabulinesep=1mm
\begin{longtabu} spread 0pt [c]{*{2}{|X[-1]}|}
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endfirsthead
\hline
\endfoot
\hline
\rowcolor{\tableheadbgcolor}\textbf{ value of Entry\+Type }&\textbf{ Meaning and conditions 

}\\\cline{1-2}
\endhead
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa981045d76077160a65da34e56daa04ba}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+Started}} &Fired when \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} begins.  

\\\cline{1-2}
Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+Before\+Save\+Entry &Fired within \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}, just before writing data for each particular entry.  

\\\cline{1-2}
Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+After\+Save\+Entry &Fired within \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}}, just after having finished writing data for each particular entry.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fa3548b0e40a71a225262bd6326a4aa412}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+Completed}} &Fired when \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Zip\+File.\+Save()}} has completed.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841faa1abc8670cbcfef255121364a3cf8bd8}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+After\+Save\+Temp\+Archive}} &Fired after the temporary file has been created. This happens only when saving to a disk file. This event will not be invoked when saving to a stream.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841faf723a2db08c9133606c2ad6621db8bfa}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+Before\+Rename\+Temp\+Archive}} &Fired just before renaming the temporary file to the permanent location. This happens only when saving to a disk file. This event will not be invoked when saving to a stream.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fae54724e2102b8488d767c1341635a704}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+After\+Rename\+Temp\+Archive}} &Fired just after renaming the temporary file to the permanent location. This happens only when saving to a disk file. This event will not be invoked when saving to a stream.  

\\\cline{1-2}
\mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841fafd6c4de11ac69e68ca709f43e21ddeab}{Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+After\+Compile\+Self\+Extractor}} &Fired after a self-\/extracting archive has finished compiling. This Event\+Type is used only within \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3e4012ae734e280075bcc9ac5a29f304}{Save\+Self\+Extractor()}}.  

\\\cline{1-2}
Zip\+Progress\+Event\+Type.\+Saving\+\_\+\+Bytes\+Read &Set during the save of a particular entry, to update progress of the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}. When this Event\+Type is set, the Bytes\+Transferred is the number of bytes that have been read from the source stream. The Total\+Bytes\+To\+Transfer is the number of bytes in the uncompressed file.  

\\\cline{1-2}
\end{longtabu}


This example uses an anonymous method to handle the Save\+Progress event, by updating a progress bar.


\begin{DoxyCode}
progressBar1.Value = 0;
progressBar1.Max = listbox1.Items.Count;
\textcolor{keyword}{using} (\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
\{
   \textcolor{comment}{// listbox1 contains a list of filenames}
   zip.AddFiles(listbox1.Items);

   \textcolor{comment}{// do the progress bar:}
   zip.SaveProgress += (sender, e) => \{
      \textcolor{keywordflow}{if} (e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_BeforeWriteEntry) \{
         progressBar1.PerformStep();
      \}
   \};

   zip.Save(fs);
\}
\end{DoxyCode}
 

This example uses a named method as the {\ttfamily Save\+Progress} event handler, to update the user, in a console-\/based application.


\begin{DoxyCode}
\textcolor{keyword}{static} \textcolor{keywordtype}{bool} justHadByteUpdate= \textcolor{keyword}{false};
\textcolor{keyword}{public} \textcolor{keyword}{static} \textcolor{keywordtype}{void} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{SaveProgress}}(\textcolor{keywordtype}{object} sender, SaveProgressEventArgs e)
\{
    \textcolor{keywordflow}{if} (e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_Started)
        Console.WriteLine(\textcolor{stringliteral}{"Saving: \{0\}"}, e.ArchiveName);

    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_Completed)
    \{
        justHadByteUpdate= \textcolor{keyword}{false};
        Console.WriteLine();
        Console.WriteLine(\textcolor{stringliteral}{"Done: \{0\}"}, e.ArchiveName);
    \}

    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_BeforeWriteEntry)
    \{
        \textcolor{keywordflow}{if} (justHadByteUpdate)
            Console.WriteLine();
        Console.WriteLine(\textcolor{stringliteral}{"  Writing: \{0\} (\{1\}/\{2\})"},
                          e.CurrentEntry.FileName, e.EntriesSaved, e.EntriesTotal);
        justHadByteUpdate= \textcolor{keyword}{false};
    \}

    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (e.EventType == \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_EntryBytesRead)
    \{
        \textcolor{keywordflow}{if} (justHadByteUpdate)
            Console.SetCursorPosition(0, Console.CursorTop);
         Console.Write(\textcolor{stringliteral}{"     \{0\}/\{1\} (\{2:N0\}%)"}, e.BytesTransferred, e.TotalBytesToTransfer,
                      e.BytesTransferred / (0.01 * e.TotalBytesToTransfer ));
        justHadByteUpdate= \textcolor{keyword}{true};
    \}
\}

\textcolor{keyword}{public} \textcolor{keyword}{static} ZipUp(\textcolor{keywordtype}{string} targetZip, \textcolor{keywordtype}{string} directory)
\{
  \textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}()) \{
    zip.SaveProgress += \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a8dba89f1c420891509a7492b53d537b1}{SaveProgress}};
    zip.AddDirectory(directory);
    zip.Save(targetZip);
  \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Public Sub ZipUp(ByVal targetZip As String, ByVal directory As String)
    Using zip As \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}} = New \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}
        AddHandler zip.SaveProgress, AddressOf MySaveProgress
        zip.AddDirectory(directory)
        zip.Save(targetZip)
    End Using
End Sub

Private Shared justHadByteUpdate As Boolean = False

Public Shared Sub MySaveProgress(ByVal sender As Object, ByVal e As SaveProgressEventArgs)
    If (e.EventType Is \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_Started) Then
        Console.WriteLine(\textcolor{stringliteral}{"Saving: \{0\}"}, e.ArchiveName)

    ElseIf (e.EventType Is \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_Completed) Then
        justHadByteUpdate = False
        Console.WriteLine
        Console.WriteLine(\textcolor{stringliteral}{"Done: \{0\}"}, e.ArchiveName)

    ElseIf (e.EventType Is \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_BeforeWriteEntry) Then
        If justHadByteUpdate Then
            Console.WriteLine
        End If
        Console.WriteLine(\textcolor{stringliteral}{"  Writing: \{0\} (\{1\}/\{2\})"}, e.CurrentEntry.FileName, e.EntriesSaved, e.
      EntriesTotal)
        justHadByteUpdate = False

    ElseIf (e.EventType Is \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_EntryBytesRead) Then
        If justHadByteUpdate Then
            Console.SetCursorPosition(0, Console.CursorTop)
        End If
        Console.Write(\textcolor{stringliteral}{"     \{0\}/\{1\} (\{2:N0\}%)"}, e.BytesTransferred, \_
                      e.TotalBytesToTransfer, \_
                      (CDbl(e.BytesTransferred) / (0.01 * e.TotalBytesToTransfer)))
        justHadByteUpdate = True
    End If
End Sub
\end{DoxyCode}
 

This is a more complete example of using the Save\+Progress events in a Windows Forms application, with a Thread object.


\begin{DoxyCode}
delegate \textcolor{keywordtype}{void} SaveEntryProgress(SaveProgressEventArgs e);
delegate \textcolor{keywordtype}{void} ButtonClick(\textcolor{keywordtype}{object} sender, EventArgs e);

\textcolor{keyword}{public} \textcolor{keyword}{class }WorkerOptions
\{
    \textcolor{keyword}{public} \textcolor{keywordtype}{string} ZipName;
    \textcolor{keyword}{public} \textcolor{keywordtype}{string} Folder;
    \textcolor{keyword}{public} \textcolor{keywordtype}{string} Encoding;
    \textcolor{keyword}{public} \textcolor{keywordtype}{string} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a4d8602c29143130a656864c17408d9e9}{Comment}};
    \textcolor{keyword}{public} \textcolor{keywordtype}{int} ZipFlavor;
    \textcolor{keyword}{public} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64Option}} Zip64;
\}

\textcolor{keyword}{private} \textcolor{keywordtype}{int} \_progress2MaxFactor;
\textcolor{keyword}{private} \textcolor{keywordtype}{bool} \_saveCanceled;
\textcolor{keyword}{private} \textcolor{keywordtype}{long} \_totalBytesBeforeCompress;
\textcolor{keyword}{private} \textcolor{keywordtype}{long} \_totalBytesAfterCompress;
\textcolor{keyword}{private} Thread \_workerThread;


\textcolor{keyword}{private} \textcolor{keywordtype}{void} btnZipup\_Click(\textcolor{keywordtype}{object} sender, EventArgs e)
\{
    KickoffZipup();
\}

\textcolor{keyword}{private} \textcolor{keywordtype}{void} btnCancel\_Click(\textcolor{keywordtype}{object} sender, EventArgs e)
\{
    \textcolor{keywordflow}{if} (this.lblStatus.InvokeRequired)
    \{
        this.lblStatus.Invoke(\textcolor{keyword}{new} ButtonClick(this.btnCancel\_Click), \textcolor{keyword}{new} \textcolor{keywordtype}{object}[] \{ sender, e \});
    \}
    \textcolor{keywordflow}{else}
    \{
        \_saveCanceled = \textcolor{keyword}{true};
        lblStatus.Text = \textcolor{stringliteral}{"Canceled..."};
        ResetState();
    \}
\}

\textcolor{keyword}{private} \textcolor{keywordtype}{void} KickoffZipup()
\{
    \_folderName = tbDirName.Text;

    \textcolor{keywordflow}{if} (\_folderName == null || \_folderName == \textcolor{stringliteral}{""}) \textcolor{keywordflow}{return};
    \textcolor{keywordflow}{if} (this.tbZipName.Text == null || \textcolor{keyword}{this}.tbZipName.Text == \textcolor{stringliteral}{""}) \textcolor{keywordflow}{return};

    \textcolor{comment}{// check for existence of the zip file:}
    \textcolor{keywordflow}{if} (\mbox{\hyperlink{namespace_system}{System}}.IO.File.Exists(\textcolor{keyword}{this}.tbZipName.Text))
    \{
        var dlgResult = MessageBox.Show(String.Format(\textcolor{stringliteral}{"The file you have specified (\{0\}) already exists."} +
                                                      \textcolor{stringliteral}{"  Do you want to overwrite this file?"}, \textcolor{keyword}{this}.
      tbZipName.Text),
                                        \textcolor{stringliteral}{"Confirmation is Required"}, MessageBoxButtons.YesNo, MessageBoxIcon
      .Question);
        \textcolor{keywordflow}{if} (dlgResult != DialogResult.Yes) \textcolor{keywordflow}{return};
        \mbox{\hyperlink{namespace_system}{System}}.IO.File.Delete(this.tbZipName.Text);
    \}

     \_saveCanceled = \textcolor{keyword}{false};
    \_nFilesCompleted = 0;
    \_totalBytesAfterCompress = 0;
    \_totalBytesBeforeCompress = 0;
    this.btnOk.Enabled = \textcolor{keyword}{false};
    this.btnOk.Text = \textcolor{stringliteral}{"Zipping..."};
    this.btnCancel.Enabled = \textcolor{keyword}{true};
    lblStatus.Text = \textcolor{stringliteral}{"Zipping..."};

    var options = \textcolor{keyword}{new} WorkerOptions
    \{
        ZipName = this.tbZipName.Text,
        Folder = \_folderName,
        Encoding = \textcolor{stringliteral}{"ibm437"}
    \};

    \textcolor{keywordflow}{if} (this.comboBox1.SelectedIndex != 0)
    \{
        options.Encoding = this.comboBox1.SelectedItem.ToString();
    \}

    \textcolor{keywordflow}{if} (this.radioFlavorSfxCmd.Checked)
        options.ZipFlavor = 2;
    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.radioFlavorSfxGui.Checked)
        options.ZipFlavor = 1;
    \textcolor{keywordflow}{else} options.ZipFlavor = 0;

    \textcolor{keywordflow}{if} (this.radioZip64AsNecessary.Checked)
        options.Zip64 = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64Option}}.AsNecessary;
    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (this.radioZip64Always.Checked)
        options.Zip64 = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64Option}}.Always;
    \textcolor{keywordflow}{else} options.Zip64 = \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a0c873ba2a5b73de966e876643830dc69}{Zip64Option}}.Never;

    options.Comment = String.Format(\textcolor{stringliteral}{"Encoding:\{0\} || Flavor:\{1\} || ZIP64:\{2\}\(\backslash\)r\(\backslash\)nCreated at \{3\} || \{4\}\(\backslash\)r\(\backslash\)n"},
                options.Encoding,
                FlavorToString(options.ZipFlavor),
                options.Zip64.ToString(),
                \mbox{\hyperlink{namespace_system}{System}}.DateTime.Now.ToString(\textcolor{stringliteral}{"yyyy-MMM-dd HH:mm:ss"}),
                this.Text);

    \textcolor{keywordflow}{if} (this.tbComment.Text != TB\_COMMENT\_NOTE)
        options.Comment += this.tbComment.Text;

    \_workerThread = \textcolor{keyword}{new} Thread(this.DoSave);
    \_workerThread.Name = \textcolor{stringliteral}{"Zip Saver thread"};
    \_workerThread.Start(options);
    this.Cursor = Cursors.WaitCursor;
 \}


\textcolor{keyword}{private} \textcolor{keywordtype}{void} DoSave(Object p)
\{
    WorkerOptions options = p as WorkerOptions;
    \textcolor{keywordflow}{try}
    \{
        \textcolor{keyword}{using} (var zip1 = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
        \{
            zip1.ProvisionalAlternateEncoding = \mbox{\hyperlink{namespace_system}{System}}.Text.Encoding.GetEncoding(options.Encoding);
            zip1.Comment = options.Comment;
            zip1.AddDirectory(options.Folder);
            \_entriesToZip = zip1.EntryFileNames.Count;
            SetProgressBars();
            zip1.SaveProgress += this.zip1\_SaveProgress;

            zip1.UseZip64WhenSaving = options.Zip64;

            \textcolor{keywordflow}{if} (options.ZipFlavor == 1)
                zip1.SaveSelfExtractor(options.ZipName, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.
      WinFormsApplication);
            \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (options.ZipFlavor == 2)
                zip1.SaveSelfExtractor(options.ZipName, \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_aa52d746f0c73d4f07fe6b2d188979963}{SelfExtractorFlavor}}.
      ConsoleApplication);
            \textcolor{keywordflow}{else}
                zip1.Save(options.ZipName);
        \}
    \}
    \textcolor{keywordflow}{catch} (\mbox{\hyperlink{namespace_system}{System}}.Exception exc1)
    \{
        MessageBox.Show(String.Format(\textcolor{stringliteral}{"Exception while zipping: \{0\}"}, exc1.Message));
        btnCancel\_Click(null, null);
    \}
\}



\textcolor{keywordtype}{void} zip1\_SaveProgress(\textcolor{keywordtype}{object} sender, SaveProgressEventArgs e)
\{
    \textcolor{keywordflow}{switch} (e.EventType)
    \{
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_AfterWriteEntry:
            StepArchiveProgress(e);
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_EntryBytesRead:
            StepEntryProgress(e);
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_Completed:
            SaveCompleted();
            \textcolor{keywordflow}{break};
        \textcolor{keywordflow}{case} \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a6584db8196e626ddfc455e74d31a841f}{ZipProgressEventType}}.Saving\_AfterSaveTempArchive:
            \textcolor{comment}{// this event only occurs when saving an SFX file}
            TempArchiveSaved();
            \textcolor{keywordflow}{break};
    \}
    \textcolor{keywordflow}{if} (\_saveCanceled)
        e.Cancel = \textcolor{keyword}{true};
\}



\textcolor{keyword}{private} \textcolor{keywordtype}{void} StepArchiveProgress(SaveProgressEventArgs e)
\{
    \textcolor{keywordflow}{if} (this.progressBar1.InvokeRequired)
    \{
        this.progressBar1.Invoke(\textcolor{keyword}{new} SaveEntryProgress(this.StepArchiveProgress), \textcolor{keyword}{new} \textcolor{keywordtype}{object}[] \{ e \});
    \}
    \textcolor{keywordflow}{else}
    \{
        \textcolor{keywordflow}{if} (!\_saveCanceled)
        \{
            \_nFilesCompleted++;
            this.progressBar1.PerformStep();
            \_totalBytesAfterCompress += e.CurrentEntry.CompressedSize;
            \_totalBytesBeforeCompress += e.CurrentEntry.UncompressedSize;

            \textcolor{comment}{// reset the progress bar for the entry:}
            this.progressBar2.Value = this.progressBar2.Maximum = 1;

            this.Update();
        \}
    \}
\}


\textcolor{keyword}{private} \textcolor{keywordtype}{void} StepEntryProgress(SaveProgressEventArgs e)
\{
    \textcolor{keywordflow}{if} (this.progressBar2.InvokeRequired)
    \{
        this.progressBar2.Invoke(\textcolor{keyword}{new} SaveEntryProgress(this.StepEntryProgress), \textcolor{keyword}{new} \textcolor{keywordtype}{object}[] \{ e \});
    \}
    \textcolor{keywordflow}{else}
    \{
        \textcolor{keywordflow}{if} (!\_saveCanceled)
        \{
            \textcolor{keywordflow}{if} (this.progressBar2.Maximum == 1)
            \{
                \textcolor{comment}{// reset}
                Int64 max = e.TotalBytesToTransfer;
                \_progress2MaxFactor = 0;
                \textcolor{keywordflow}{while} (max > \mbox{\hyperlink{namespace_system}{System}}.Int32.MaxValue)
                \{
                    max /= 2;
                    \_progress2MaxFactor++;
                \}
                this.progressBar2.Maximum = (int)max;
                lblStatus.Text = String.Format(\textcolor{stringliteral}{"\{0\} of \{1\} files...(\{2\})"},
                    \_nFilesCompleted + 1, \_entriesToZip, e.CurrentEntry.FileName);
            \}

             \textcolor{keywordtype}{int} xferred = e.BytesTransferred >> \_progress2MaxFactor;

             this.progressBar2.Value = (xferred >= this.progressBar2.Maximum)
                ? this.progressBar2.Maximum
                : xferred;

             \textcolor{keyword}{this}.Update();
        \}
    \}
\}

\textcolor{keyword}{private} \textcolor{keywordtype}{void} SaveCompleted()
\{
    \textcolor{keywordflow}{if} (this.lblStatus.InvokeRequired)
    \{
        this.lblStatus.Invoke(\textcolor{keyword}{new} MethodInvoker(this.SaveCompleted));
    \}
    \textcolor{keywordflow}{else}
    \{
        lblStatus.Text = String.Format(\textcolor{stringliteral}{"Done, Compressed \{0\} files, \{1:N0\}% of original."},
            \_nFilesCompleted, (100.00 * \_totalBytesAfterCompress) / \_totalBytesBeforeCompress);
         ResetState();
    \}
\}

\textcolor{keyword}{private} \textcolor{keywordtype}{void} ResetState()
\{
    this.btnCancel.Enabled = \textcolor{keyword}{false};
    this.btnOk.Enabled = \textcolor{keyword}{true};
    this.btnOk.Text = \textcolor{stringliteral}{"Zip it!"};
    this.progressBar1.Value = 0;
    this.progressBar2.Value = 0;
    this.Cursor = Cursors.Default;
    \textcolor{keywordflow}{if} (!\_workerThread.IsAlive)
        \_workerThread.Join();
\}
\end{DoxyCode}


\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_ab12db01739c524bfab29994e6a2530f3}{Ionic.\+Zip.\+Zip\+File.\+Read\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a3c898fc2c5c70405e836f9454621c556}{Ionic.\+Zip.\+Zip\+File.\+Add\+Progress}}, \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a349a9506f5a323204672eaa3e1a269bf}{Ionic.\+Zip.\+Zip\+File.\+Extract\+Progress}}


\end{DoxySeeAlso}
\mbox{\Hypertarget{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9c72461567386905e4e52ccb312e4812}\label{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a9c72461567386905e4e52ccb312e4812}} 
\index{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}!Zip\+Error@{Zip\+Error}}
\index{Zip\+Error@{Zip\+Error}!Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File@{Super\+Tiled2\+Unity\+::\+Ionic\+::\+Zip\+::\+Zip\+File}}
\subsubsection{\texorpdfstring{Zip\+Error}{ZipError}}
{\footnotesize\ttfamily Event\+Handler$<$\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_error_event_args}{Zip\+Error\+Event\+Args}}$>$ Super\+Tiled2\+Unity.\+Ionic.\+Zip.\+Zip\+File.\+Zip\+Error}



An event that is raised when an error occurs during open or read of files while saving a zip archive. 

Errors can occur as a file is being saved to the zip archive. For example, the File.\+Open may fail, or a File.\+Read may fail, because of lock conflicts or other reasons. If you add a handler to this event, you can handle such errors in your own code. If you don\textquotesingle{}t add a handler, the library will throw an exception if it encounters an I/O error during a call to {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}. 

Setting a handler implicitly sets \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Zip\+File.\+Zip\+Error\+Action}} to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a438494fa2a47a746a5f0660862a5bf68}{Zip\+Error\+Action.\+Invoke\+Error\+Event}}}. 

The handler you add applies to all \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}} items that are subsequently added to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}} instance. If you set this property after you have added items to the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file}{Zip\+File}}}, but before you have called {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}}, errors that occur while saving those items will not cause the error handler to be invoked. 

If you want to handle any errors that occur with any entry in the zip file using the same error handler, then add your error handler once, before adding any entries to the zip archive. 

In the error handler method, you need to set the \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a55a679298f00c5eef672e947c6293304}{Zip\+Entry.\+Zip\+Error\+Action}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_progress_event_args_aa2cf173f83591b5b52e15ca4c9d34129}{Zip\+Error\+Event\+Args.\+Current\+Entry}}}. This communicates back to Dot\+Net\+Zip what you would like to do with this particular error. Within an error handler, if you set the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a55a679298f00c5eef672e947c6293304}{Zip\+Entry.\+Zip\+Error\+Action}}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a438494fa2a47a746a5f0660862a5bf68}{Zip\+Error\+Action.\+Invoke\+Error\+Event}}} or if you don\textquotesingle{}t set it at all, the library will throw the exception. (It is the same as if you had set the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry_a55a679298f00c5eef672e947c6293304}{Zip\+Entry.\+Zip\+Error\+Action}}} property on the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_entry}{Zip\+Entry}}} to {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a3f8db7242d746d36b45114257b4fe4c0a8ce61dd2505effd96f937fa743b6491f}{Zip\+Error\+Action.\+Throw}}}.) If you set the {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_progress_event_args_a91248747aca5704f3cab69af3a289028}{Zip\+Error\+Event\+Args.\+Cancel}}} to true, the entire {\ttfamily \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_aff8f1b3d07b66481e2629b04017a056f}{Save()}}} will be canceled. 

In the case that you use {\ttfamily \mbox{\hyperlink{namespace_super_tiled2_unity_1_1_ionic_1_1_zip_a5597d8881459658d304cdc5fdae35593a72ef2b9b6965d078e3c7f95487a82d1c}{Zip\+Error\+Action.\+Skip}}}, implying that you want to skip the entry for which there\textquotesingle{}s been an error, Dot\+Net\+Zip tries to seek backwards in the output stream, and truncate all bytes written on behalf of that particular entry. This works only if the output stream is seekable. It will not work, for example, when using A\+S\+P\+N\+ET\textquotesingle{}s Response.\+Output\+Stream. 

This example shows how to use an event handler to handle errors during save of the zip file. 
\begin{DoxyCode}
\textcolor{keyword}{public} \textcolor{keyword}{static} \textcolor{keywordtype}{void} MyZipError(\textcolor{keywordtype}{object} sender, ZipErrorEventArgs e)
\{
    Console.WriteLine(\textcolor{stringliteral}{"Error saving \{0\}..."}, e.FileName);
    Console.WriteLine(\textcolor{stringliteral}{"   Exception: \{0\}"}, e.exception);
    ZipEntry entry = e.CurrentEntry;
    \textcolor{keywordtype}{string} response = null;
    \textcolor{comment}{// Ask the user whether he wants to skip this error or not}
    \textcolor{keywordflow}{do}
    \{
        Console.Write(\textcolor{stringliteral}{"Retry, Skip, Throw, or Cancel ? (R/S/T/C) "});
        response = Console.ReadLine();
        Console.WriteLine();

    \} \textcolor{keywordflow}{while} (response != null &amp;&amp;
             response[0]!=\textcolor{charliteral}{'S'} &amp;&amp; response[0]!=\textcolor{charliteral}{'s'} &amp;&amp;
             response[0]!=\textcolor{charliteral}{'R'} &amp;&amp; response[0]!=\textcolor{charliteral}{'r'} &amp;&amp;
             response[0]!=\textcolor{charliteral}{'T'} &amp;&amp; response[0]!=\textcolor{charliteral}{'t'} &amp;&amp;
             response[0]!=\textcolor{charliteral}{'C'} &amp;&amp; response[0]!=\textcolor{charliteral}{'c'});

    e.Cancel = (response[0]==\textcolor{charliteral}{'C'} || response[0]==\textcolor{charliteral}{'c'});

    \textcolor{keywordflow}{if} (response[0]==\textcolor{charliteral}{'S'} || response[0]==\textcolor{charliteral}{'s'})
        entry.ZipErrorAction = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{ZipErrorAction}}.Skip;
    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (response[0]==\textcolor{charliteral}{'R'} || response[0]==\textcolor{charliteral}{'r'})
        entry.ZipErrorAction = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{ZipErrorAction}}.Retry;
    \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (response[0]==\textcolor{charliteral}{'T'} || response[0]==\textcolor{charliteral}{'t'})
        entry.ZipErrorAction = \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{ZipErrorAction}}.Throw;
\}

\textcolor{keyword}{public} \textcolor{keywordtype}{void} SaveTheFile()
\{
  \textcolor{keywordtype}{string} directoryToZip = \textcolor{stringliteral}{"fodder"};
  \textcolor{keywordtype}{string} directoryInArchive = \textcolor{stringliteral}{"files"};
  \textcolor{keywordtype}{string} zipFileToCreate = \textcolor{stringliteral}{"Archive.zip"};
  \textcolor{keyword}{using} (var zip = \textcolor{keyword}{new} \mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a59f2e1a6fddd0f283c00c7f0f1d20cce}{ZipFile}}())
  \{
    \textcolor{comment}{// set the event handler before adding any entries}
    zip.ZipError += MyZipError;
    zip.AddDirectory(directoryToZip, directoryInArchive);
    zip.Save(zipFileToCreate);
  \}
\}
\end{DoxyCode}



\begin{DoxyCode}
Private Sub MyZipError(ByVal sender As Object, ByVal e As Ionic.Zip.ZipErrorEventArgs)
    \textcolor{stringliteral}{' At this point, the application could prompt the user for an action to take.}
\textcolor{stringliteral}{    '} But in \textcolor{keyword}{this} \textcolor{keywordflow}{case}, \textcolor{keyword}{this} application will simply automatically skip the file, in \textcolor{keywordflow}{case} of error.
    Console.WriteLine(\textcolor{stringliteral}{"Zip Error,  entry \{0\}"}, e.CurrentEntry.FileName)
    Console.WriteLine(\textcolor{stringliteral}{"   Exception: \{0\}"}, e.exception)
    \textcolor{stringliteral}{' set the desired ZipErrorAction on the CurrentEntry to communicate that to DotNetZip}
\textcolor{stringliteral}{    e.CurrentEntry.ZipErrorAction = Zip.ZipErrorAction.Skip}
\textcolor{stringliteral}{End Sub}
\textcolor{stringliteral}{}
\textcolor{stringliteral}{Public Sub SaveTheFile()}
\textcolor{stringliteral}{    Dim directoryToZip As String = "fodder"}
\textcolor{stringliteral}{    Dim directoryInArchive As String = "files"}
\textcolor{stringliteral}{    Dim zipFileToCreate as String = "Archive.zip"}
\textcolor{stringliteral}{    Using zipArchive As ZipFile = New ZipFile}
\textcolor{stringliteral}{        '} \textcolor{keyword}{set} the \textcolor{keyword}{event} handler before adding any entries
        AddHandler zipArchive.ZipError, AddressOf MyZipError
        zipArchive.AddDirectory(directoryToZip, directoryInArchive)
        zipArchive.Save(zipFileToCreate)
    End Using
End Sub
\end{DoxyCode}
 

\begin{DoxySeeAlso}{See also}
\mbox{\hyperlink{class_super_tiled2_unity_1_1_ionic_1_1_zip_1_1_zip_file_a68ea59eb815f14ecc6f060da3a77e5a6}{Ionic.\+Zip.\+Zip\+File.\+Zip\+Error\+Action}}


\end{DoxySeeAlso}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Add\+Update.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Check.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Events.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Save\+Self\+Extractor.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Extract.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Read.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Save.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+Selector.\+cs\item 
D\+:/\+Users/\+Bennett/\+Desktop/\+School/\+E\+E\+C\+S\+\_\+448/\+Catch-\/the-\/\+Bus/\+Iso\+Chai/\+Assets/\+Super\+Tiled2\+Unity/\+Scripts/\+Editor/\+Third\+Party/dotnetzip-\/for-\/unity/\+Zip/Zip\+File.\+x-\/\+I\+Enumerable.\+cs\end{DoxyCompactItemize}
